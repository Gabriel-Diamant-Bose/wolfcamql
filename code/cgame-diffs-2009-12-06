diff -Naur cgame.orig/cg_consolecmds.c cgame/cg_consolecmds.c
--- cgame.orig/cg_consolecmds.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_consolecmds.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,30 +1,12 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_consolecmds.c -- text commands typed in at the local console, or
 // executed by a key binding
 
 #include "cg_local.h"
 #include "../ui/ui_shared.h"
+#include "wolfcam_local.h"
+
 #ifdef MISSIONPACK
 extern menuDef_t *menuScoreboard;
 #endif
@@ -84,7 +66,7 @@
 }
 
 
-static void CG_ScoresDown_f( void ) {
+void CG_ScoresDown_f( void ) {
 
 #ifdef MISSIONPACK
 		CG_BuildSpectatorString();
@@ -99,7 +81,8 @@
 		// displayed, but if this is the first hit, clear them out
 		if ( !cg.showScores ) {
 			cg.showScores = qtrue;
-			cg.numScores = 0;
+            if (!cg.demoPlayback)
+                cg.numScores = 0;
 		}
 	} else {
 		// show the cached contents even if they just pressed if it
@@ -108,7 +91,7 @@
 	}
 }
 
-static void CG_ScoresUp_f( void ) {
+void CG_ScoresUp_f( void ) {
 	if ( cg.showScores ) {
 		cg.showScores = qfalse;
 		cg.scoreFadeTime = cg.time;
@@ -117,7 +100,7 @@
 
 #ifdef MISSIONPACK
 extern menuDef_t *menuScoreboard;
-void Menu_Reset( void );			// FIXME: add to right include file
+void Menu_Reset();			// FIXME: add to right include file
 
 static void CG_LoadHud_f( void) {
   char buff[1024];
@@ -500,7 +483,12 @@
 #endif
 	{ "startOrbit", CG_StartOrbit_f },
 	//{ "camera", CG_Camera_f },
-	{ "loaddeferred", CG_LoadDeferredPlayers }	
+	{ "loaddeferred", CG_LoadDeferredPlayers },
+    { "players", Wolfcam_Players_f },
+    { "playersw", Wolfcam_Playersw_f },
+    { "follow", Wolfcam_Follow_f },
+    { "wcstats", Wolfcam_Weapon_Stats_f },
+    { "wcstatsall", Wolfcam_Weapon_Statsall_f }
 };
 
 
diff -Naur cgame.orig/cg_draw.c cgame/cg_draw.c
--- cgame.orig/cg_draw.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_draw.c	2009-12-06 17:18:03.000000000 -0500
@@ -1,29 +1,10 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_draw.c -- draw all of the graphical elements during
 // active (after loading) gameplay
 
 #include "cg_local.h"
+#include "wolfcam_local.h"
 
 #ifdef MISSIONPACK
 #include "../ui/ui_shared.h"
@@ -42,6 +23,180 @@
 char teamChat1[256];
 char teamChat2[256];
 
+static float Wolfcam_DrawSpeed (float y)
+{
+    char *s;
+    int w;
+    float speed;
+    int c;
+
+    if (!wolfcam_following) {
+        speed = cg.xyspeed;
+    } else {
+        if (wcg.clientNum != cg.snap->ps.clientNum) {
+            entityState_t *es;
+
+            es = &cg_entities[wcg.clientNum].currentState;
+            speed = sqrt (es->pos.trDelta[0] * es->pos.trDelta[0] + es->pos.trDelta[1] * es->pos.trDelta[1]);
+        } else {
+            playerState_t *ps;
+
+            //ps = &cg.predictedPlayerState;
+            ps = &cg.snap->ps;
+            speed = sqrt( ps->velocity[0] * ps->velocity[0] +
+                          ps->velocity[1] * ps->velocity[1] );
+        }
+    }
+
+    if (speed >= 820.0)
+        c = 6;
+    else if (speed >= 720.0)
+        c = 5;
+    else if (speed >= 620.0)
+        c = 1;
+    else if (speed >= 520.0)
+        c = 4;
+    else if (speed >= 420.0)
+        c = 3;
+    else if (speed >= 320.0)
+        c = 2;
+    else
+        c = 7;
+
+    //s = va("%.2f UPS", speed);
+    s = va("^%d%d ^7UPS", c, (int)speed);
+    w = CG_DrawStrlen(s) * BIGCHAR_WIDTH;
+
+    CG_DrawBigString (635 - w, y + 2, s, 1.0f);
+
+    return y + BIGCHAR_HEIGHT + 4;
+}
+
+static float Wolfcam_DrawMouseSpeed (float y)
+{
+    char *s;
+    int w;
+    float sy, sx;
+    //playerState_t *ps;
+    //static vec3_t oldangles = { 0.0, 0.0, 0.0 };                              
+    //static int oldServerTime = -1;                                            
+    vec3_t oldAngles;
+    vec3_t newAngles;
+	//int i;
+
+	return y;
+
+#if 0
+    s = va ("%f %f %f",
+			cg.snap->ps.origin[0],
+			cg.snap->ps.origin[1],
+			cg.snap->ps.origin[2]
+
+			//sy, sx
+            );
+    w = CG_DrawStrlen(s) * BIGCHAR_WIDTH;
+
+    CG_DrawBigString (635 - w, y + 2, s, 1.0f);
+
+	return y + BIGCHAR_HEIGHT + 4;
+
+	if (wolfcam_following) {
+		//FIXME wolfcam
+		//return y;
+	}
+
+	sy = 0.0;
+	sx = 0.0;
+
+#if 0
+	for (i = 30;  i > 0;  i--) {
+		VectorCopy (wcg.snaps[(wcg.curSnapshotNumber - i - 1) & MAX_SNAPSHOT_MASK].ps.viewangles, oldAngles);
+		VectorCopy (wcg.snaps[(wcg.curSnapshotNumber - i) & MAX_SNAPSHOT_MASK].ps.viewangles, newAngles);
+		sy += newAngles[0] - oldAngles[0];
+		sx += newAngles[1] - oldAngles[1];
+	}
+	sy /= 30.0;
+	sx /= 30.0;
+#endif
+
+	VectorCopy (wcg.snaps[(wcg.curSnapshotNumber - 2) & MAX_SNAPSHOT_MASK].ps.viewangles, oldAngles);
+    VectorCopy (cg.snap->ps.viewangles, newAngles);
+
+
+
+#if 0
+    speed = sqrt (ps->delta_angles[0] * ps->delta_angles[0]  +
+                  ps->delta_angles[1] * ps->delta_angles[1]  +
+                  ps->delta_angles[2] * ps->delta_angles[2]  +
+                  ps->delta_angles[3] * ps->delta_angles[3]
+                  );
+#endif
+    //s = va ("%f %f %f", speed);                                               
+    s = va ("%0.3f %0.3f",
+            (newAngles[0] - oldAngles[0]) * 20,
+            (newAngles[1] - oldAngles[1]) * 20
+			//sy, sx
+            );
+    w = CG_DrawStrlen(s) * BIGCHAR_WIDTH;
+
+    CG_DrawBigString (635 - w, y + 2, s, 1.0f);
+
+#if 0
+    CG_Printf ("%f %f %f\n",
+               cg.predictedPlayerState.delta_angles[0],
+               cg.predictedPlayerState.delta_angles[1],
+               cg.predictedPlayerState.delta_angles[2],
+               cg.predictedPlayerState.delta_angles[3]
+               );
+#endif
+
+    return y + BIGCHAR_HEIGHT + 4;
+#endif
+}
+
+static void Wolfcam_DrawFollowing (void)
+{
+    const char *s;
+    const char *scolor;
+    int w;
+    qboolean visible;
+
+    if (!wolfcam_following)
+        return;
+
+    //FIXME wolfcam could be in limbo or not visible
+    //if (cg_entities[cgs.clientinfo[wcg.clientNum].clientNum].currentValid  ||
+    //    cg.snap->ps.clientNum == wcg.clientNum)
+    if (wclients[wcg.clientNum].currentValid)
+        visible = qtrue;
+    else
+        visible = qfalse;
+
+    if (visible)
+        scolor = S_COLOR_WHITE;
+    else
+        scolor = S_COLOR_RED;
+
+    s = va ("%sFollowing^7 %s", scolor, cgs.clientinfo[wcg.clientNum].name);
+    w = CG_DrawStrlen(s) * SMALLCHAR_WIDTH;
+    CG_DrawSmallString (320 - w/2 + 14, 45, s, 1.0F);
+    //CG_DrawFlagModel (320 - w/2 - 20, 80, 30, 30, TEAM_RED);
+#if 0
+    switch (cgs.clientinfo[wcg.clientNum].team) {
+    case TEAM_RED:
+        CG_DrawPic (320 - w/2 - 14, 45 + 2, 24, 14, trap_R_RegisterShaderNoMip( 
+                                                                               "ui_mp/assets/ger_flag.tga"));
+        break;
+    case TEAM_BLUE:
+        CG_DrawPic (320 - w/2 - 14, 45 + 2, 24, 14, trap_R_RegisterShaderNoMip( 
+                                                                               "ui_mp/assets/usa_flag.tga"));
+        break;
+    default:
+        break;
+    }
+#endif
+}
+
 #ifdef MISSIONPACK
 
 int CG_Text_Width(const char *text, float scale, int limit) {
@@ -522,7 +677,8 @@
 ================
 */
 #ifndef MISSIONPACK
-static void CG_DrawStatusBar( void ) {
+static void Wolfcam_DrawStatusBar (void) 
+{
 	int			color;
 	centity_t	*cent;
 	playerState_t	*ps;
@@ -530,7 +686,206 @@
 	vec4_t		hcolor;
 	vec3_t		angles;
 	vec3_t		origin;
+#ifdef MISSIONPACK
+	qhandle_t	handle;
+#endif
+	static float colors[4][4] = { 
+//		{ 0.2, 1.0, 0.2, 1.0 } , { 1.0, 0.2, 0.2, 1.0 }, {0.5, 0.5, 0.5, 1} };
+		{ 1.0f, 0.69f, 0.0f, 1.0f },    // normal
+		{ 1.0f, 0.2f, 0.2f, 1.0f },     // low health
+		{ 0.5f, 0.5f, 0.5f, 1.0f },     // weapon firing
+		{ 1.0f, 1.0f, 1.0f, 1.0f } };   // health > 100
+
+	if ( cg_drawStatus.integer == 0 ) {
+		return;
+	}
+
+    if (!wolfcam_following)
+        return;
+
+	// draw the team background
+    //FIXME wolfcam
+	//CG_DrawTeamBackground( 0, 420, 640, 60, 0.33f, cg.snap->ps.persistant[PERS_TEAM] );
+	//CG_DrawTeamBackground(0, 420, 640, 60, 0.33f, cgs.clientinfo[wcg.clientNum].team);
+
+	cent = &cg_entities[wcg.clientNum];
+	ps = &cg.snap->ps;
+
+	VectorClear( angles );
+
+	// draw any 3D icons first, so the changes back to 2D are minimized
+	if ( cent->currentState.weapon && cg_weapons[ cent->currentState.weapon ].ammoModel ) {
+		origin[0] = 70;
+		origin[1] = 0;
+		origin[2] = 0;
+		angles[YAW] = 90 + 20 * sin( cg.time / 1000.0 );
+		CG_Draw3DModel( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
+					   cg_weapons[ cent->currentState.weapon ].ammoModel, 0, origin, angles );
+	}
+
+    //FIXME wolfcam
+	//CG_DrawStatusBarHead( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE );
+
+    //trap_R_SetColor (colors[1]);
+    if (cent->currentState.eFlags & EF_FIRING) {
+        color = 1;  // red
+    } else
+        color = 2;  // dark grey
+    trap_R_SetColor (colors[color]);
+    CG_DrawField (0, 432, 3, 0);
+    trap_R_SetColor (NULL);
+
+    //FIXME wolfcam
+    return;
+
+	if( cg.predictedPlayerState.powerups[PW_REDFLAG] ) {
+		CG_DrawStatusBarFlag( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE + ICON_SIZE, TEAM_RED );
+	} else if( cg.predictedPlayerState.powerups[PW_BLUEFLAG] ) {
+		CG_DrawStatusBarFlag( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE + ICON_SIZE, TEAM_BLUE );
+	} else if( cg.predictedPlayerState.powerups[PW_NEUTRALFLAG] ) {
+		CG_DrawStatusBarFlag( 185 + CHAR_WIDTH*3 + TEXT_ICON_SPACE + ICON_SIZE, TEAM_FREE );
+	}
+
+	if ( ps->stats[ STAT_ARMOR ] ) {
+		origin[0] = 90;
+		origin[1] = 0;
+		origin[2] = -10;
+		angles[YAW] = ( cg.time & 2047 ) * 360 / 2048.0;
+		CG_Draw3DModel( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
+					   cgs.media.armorModel, 0, origin, angles );
+	}
+#ifdef MISSIONPACK
+	if( cgs.gametype == GT_HARVESTER ) {
+		origin[0] = 90;
+		origin[1] = 0;
+		origin[2] = -10;
+		angles[YAW] = ( cg.time & 2047 ) * 360 / 2048.0;
+		if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+			handle = cgs.media.redCubeModel;
+		} else {
+			handle = cgs.media.blueCubeModel;
+		}
+		CG_Draw3DModel( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 416, ICON_SIZE, ICON_SIZE, handle, 0, origin, angles );
+	}
+#endif
+	//
+	// ammo
+	//
+	if ( cent->currentState.weapon ) {
+		value = ps->ammo[cent->currentState.weapon];
+		if ( value > -1 ) {
+			if ( cg.predictedPlayerState.weaponstate == WEAPON_FIRING
+				&& cg.predictedPlayerState.weaponTime > 100 ) {
+				// draw as dark grey when reloading
+				color = 2;	// dark grey
+			} else {
+				if ( value >= 0 ) {
+					color = 0;	// green
+				} else {
+					color = 1;	// red
+				}
+			}
+			trap_R_SetColor( colors[color] );
+			
+			CG_DrawField (0, 432, 3, value);
+			trap_R_SetColor( NULL );
+
+			// if we didn't draw a 3D icon, draw a 2D icon for ammo
+			if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+				qhandle_t	icon;
 
+				icon = cg_weapons[ cg.predictedPlayerState.weapon ].ammoIcon;
+				if ( icon ) {
+					CG_DrawPic( CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE, icon );
+				}
+			}
+		}
+	}
+
+	//
+	// health
+	//
+	value = ps->stats[STAT_HEALTH];
+	if ( value > 100 ) {
+		trap_R_SetColor( colors[3] );		// white
+	} else if (value > 25) {
+		trap_R_SetColor( colors[0] );	// green
+	} else if (value > 0) {
+		color = (cg.time >> 8) & 1;	// flash
+		trap_R_SetColor( colors[color] );
+	} else {
+		trap_R_SetColor( colors[1] );	// red
+	}
+
+	// stretch the health up when taking damage
+	CG_DrawField ( 185, 432, 3, value);
+	CG_ColorForHealth( hcolor );
+	trap_R_SetColor( hcolor );
+
+
+	//
+	// armor
+	//
+	value = ps->stats[STAT_ARMOR];
+	if (value > 0 ) {
+		trap_R_SetColor( colors[0] );
+		CG_DrawField (370, 432, 3, value);
+		trap_R_SetColor( NULL );
+		// if we didn't draw a 3D icon, draw a 2D icon for armor
+		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+			CG_DrawPic( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE, cgs.media.armorIcon );
+		}
+
+	}
+#ifdef MISSIONPACK
+	//
+	// cubes
+	//
+	if( cgs.gametype == GT_HARVESTER ) {
+		value = ps->generic1;
+		if( value > 99 ) {
+			value = 99;
+		}
+		trap_R_SetColor( colors[0] );
+		CG_DrawField (640 - (CHAR_WIDTH*2 + TEXT_ICON_SPACE + ICON_SIZE), 432, 2, value);
+		trap_R_SetColor( NULL );
+		// if we didn't draw a 3D icon, draw a 2D icon for armor
+		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+			if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+				handle = cgs.media.redCubeIcon;
+			} else {
+				handle = cgs.media.blueCubeIcon;
+			}
+			CG_DrawPic( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 432, ICON_SIZE, ICON_SIZE, handle );
+		}
+	}
+#endif
+}
+#endif  // ifndef MISSIONPACK
+#ifdef MISSIONPACK
+static void Wolfcam_DrawStatusBar (void)
+{
+}
+#endif
+
+/*
+================
+CG_DrawStatusBar
+
+================
+*/
+#ifndef MISSIONPACK
+static void CG_DrawStatusBar( void ) {
+	int			color;
+	centity_t	*cent;
+	playerState_t	*ps;
+	int			value;
+	vec4_t		hcolor;
+	vec3_t		angles;
+	vec3_t		origin;
+#ifdef MISSIONPACK
+	qhandle_t	handle;
+#endif
 	static float colors[4][4] = { 
 //		{ 0.2, 1.0, 0.2, 1.0 } , { 1.0, 0.2, 0.2, 1.0 }, {0.5, 0.5, 0.5, 1} };
 		{ 1.0f, 0.69f, 0.0f, 1.0f },    // normal
@@ -578,6 +933,20 @@
 		CG_Draw3DModel( 370 + CHAR_WIDTH*3 + TEXT_ICON_SPACE, 432, ICON_SIZE, ICON_SIZE,
 					   cgs.media.armorModel, 0, origin, angles );
 	}
+#ifdef MISSIONPACK
+	if( cgs.gametype == GT_HARVESTER ) {
+		origin[0] = 90;
+		origin[1] = 0;
+		origin[2] = -10;
+		angles[YAW] = ( cg.time & 2047 ) * 360 / 2048.0;
+		if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+			handle = cgs.media.redCubeModel;
+		} else {
+			handle = cgs.media.blueCubeModel;
+		}
+		CG_Draw3DModel( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 416, ICON_SIZE, ICON_SIZE, handle, 0, origin, angles );
+	}
+#endif
 	//
 	// ammo
 	//
@@ -647,6 +1016,29 @@
 		}
 
 	}
+#ifdef MISSIONPACK
+	//
+	// cubes
+	//
+	if( cgs.gametype == GT_HARVESTER ) {
+		value = ps->generic1;
+		if( value > 99 ) {
+			value = 99;
+		}
+		trap_R_SetColor( colors[0] );
+		CG_DrawField (640 - (CHAR_WIDTH*2 + TEXT_ICON_SPACE + ICON_SIZE), 432, 2, value);
+		trap_R_SetColor( NULL );
+		// if we didn't draw a 3D icon, draw a 2D icon for armor
+		if ( !cg_draw3dIcons.integer && cg_drawIcons.integer ) {
+			if( cg.snap->ps.persistant[PERS_TEAM] == TEAM_BLUE ) {
+				handle = cgs.media.redCubeIcon;
+			} else {
+				handle = cgs.media.blueCubeIcon;
+			}
+			CG_DrawPic( 640 - (TEXT_ICON_SPACE + ICON_SIZE), 432, ICON_SIZE, ICON_SIZE, handle );
+		}
+	}
+#endif
 }
 #endif
 
@@ -658,6 +1050,79 @@
 ===========================================================================================
 */
 
+static int attacker_num = -1;
+
+static float Wolfcam_DrawAttacker( float y ) {
+	//int			t;
+	float		size;
+	vec3_t		angles;
+	const char	*info;
+	const char	*name;
+	int			clientNum;
+    trace_t trace;
+    vec3_t start, forward, end;
+    int content;
+
+    VectorCopy (cg_entities[wcg.clientNum].currentState.pos.trBase, start);
+    AngleVectors (cg_entities[wcg.clientNum].currentState.apos.trBase, forward, NULL, NULL);
+    VectorMA (start, 131072, forward, end );
+    Wolfcam_WeaponTrace (&trace, start, vec3_origin, vec3_origin, end, wcg.clientNum, CONTENTS_SOLID|CONTENTS_BODY);
+
+    if (trace.entityNum >= MAX_CLIENTS) {
+        goto L1;
+        //return y;
+    } else {
+        attacker_num = trace.entityNum;
+        goto L1;
+    }
+    
+    // if the player is in fog, don't show it
+    content = trap_CM_PointContents( trace.endpos, 0 );
+    if ( content & CONTENTS_FOG ) {
+        return y;
+    }
+
+    // if the player is invisible, don't show it
+    if ( cg_entities[ trace.entityNum ].currentState.powerups & ( 1 << PW_INVIS ) ) {
+        return y;
+    }
+
+	//clientNum = cg.predictedPlayerState.persistant[PERS_ATTACKER];
+    clientNum = trace.entityNum;
+	if ( clientNum < 0 || clientNum >= MAX_CLIENTS || clientNum == wcg.clientNum ) {
+		return y;
+	}
+
+#if 0
+	t = cg.time - cg.attackerTime;
+	if ( t > ATTACKER_HEAD_TIME ) {
+		cg.attackerTime = 0;
+		return y;
+	}
+#endif
+
+ L1:
+    
+    if (attacker_num == -1)
+        return y;
+
+    clientNum = attacker_num;
+
+	size = ICON_SIZE * 1.25;
+
+	angles[PITCH] = 0;
+	angles[YAW] = 180;
+	angles[ROLL] = 0;
+	CG_DrawHead( 640 - size, y, size, size, clientNum, angles );
+
+	info = CG_ConfigString( CS_PLAYERS + clientNum );
+	name = Info_ValueForKey(  info, "n" );
+	y += size;
+	CG_DrawBigString( 640 - ( Q_PrintStrlen( name ) * BIGCHAR_WIDTH), y, name, 0.5 );
+
+	return y + BIGCHAR_HEIGHT + 2;
+}
+
 /*
 ================
 CG_DrawAttacker
@@ -672,6 +1137,10 @@
 	const char	*name;
 	int			clientNum;
 
+    if (wolfcam_following) {
+        return Wolfcam_DrawAttacker (y);
+    }
+
 	if ( cg.predictedPlayerState.stats[STAT_HEALTH] <= 0 ) {
 		return y;
 	}
@@ -976,8 +1445,7 @@
 
 =====================
 */
-static void CG_DrawUpperRight(stereoFrame_t stereoFrame)
-{
+static void CG_DrawUpperRight( void ) {
 	float	y;
 
 	y = 0;
@@ -988,16 +1456,19 @@
 	if ( cg_drawSnapshot.integer ) {
 		y = CG_DrawSnapshot( y );
 	}
-	if (cg_drawFPS.integer && (stereoFrame == STEREO_CENTER || stereoFrame == STEREO_RIGHT)) {
+	if ( cg_drawFPS.integer ) {
 		y = CG_DrawFPS( y );
 	}
 	if ( cg_drawTimer.integer ) {
 		y = CG_DrawTimer( y );
 	}
+    if (cg_drawSpeed.integer) {
+        y = Wolfcam_DrawSpeed (y);
+    }
+	y = Wolfcam_DrawMouseSpeed (y);
 	if ( cg_drawAttacker.integer ) {
 		y = CG_DrawAttacker( y );
 	}
-
 }
 
 /*
@@ -1084,6 +1555,19 @@
 			}
 		}
 
+#ifdef MISSIONPACK
+		if ( cgs.gametype == GT_1FCTF ) {
+			// Display flag status
+			item = BG_FindItemForPowerup( PW_NEUTRALFLAG );
+
+			if (item) {
+				y1 = y - BIGCHAR_HEIGHT - 8;
+				if( cgs.flagStatus >= 0 && cgs.flagStatus <= 3 ) {
+					CG_DrawPic( x, y1-4, w, BIGCHAR_HEIGHT+8, cgs.media.flagShader[cgs.flagStatus] );
+				}
+			}
+		}
+#endif
 		if ( cgs.gametype >= GT_CTF ) {
 			v = cgs.capturelimit;
 		} else {
@@ -1576,9 +2060,15 @@
 	if ( !snap ) {
 		lagometer.snapshotSamples[ lagometer.snapshotCount & ( LAG_SAMPLES - 1) ] = -1;
 		lagometer.snapshotCount++;
+		CG_Printf ("wolcam: missed snapshot %d\n", cg.time);
 		return;
 	}
 
+	// CHRUKER: b093 - Lagometer ping not correct during demo playback
+    if (cg.demoPlayback  &&  snap->ps.pm_type != PM_INTERMISSION  && snap->ps.clientNum == cg.clientNum) {
+		snap->ping = (snap->serverTime - snap->ps.commandTime) - 50;
+	}
+
 	// add this snapshot's info
 	lagometer.snapshotSamples[ lagometer.snapshotCount & ( LAG_SAMPLES - 1) ] = snap->ping;
 	lagometer.snapshotFlags[ lagometer.snapshotCount & ( LAG_SAMPLES - 1) ] = snap->snapFlags;
@@ -1597,18 +2087,22 @@
 	int			cmdNum;
 	usercmd_t	cmd;
 	const char		*s;
-	int			w;
+	int			w;  // bk010215 - FIXME char message[1024];
 
 	// draw the phone jack if we are completely past our buffers
 	cmdNum = trap_GetCurrentCmdNumber() - CMD_BACKUP + 1;
 	trap_GetUserCmd( cmdNum, &cmd );
 	if ( cmd.serverTime <= cg.snap->ps.commandTime
-		|| cmd.serverTime > cg.time ) {	// special check for map_restart
+		|| cmd.serverTime > cg.time ) {	// special check for map_restart // bk 0102165 - FIXME
 		return;
 	}
+    
+    //CG_Printf ("cmd.serverTime:%d  cg.snap->ps.commandTime:%d  cg.time:%d\n", cmd.serverTime, cg.snap->ps.commandTime, cg.time);
+    if (cg.demoPlayback  &&  cg_timescale.value != 1.0f)
+        return;
 
 	// also add text in center of screen
-	s = "Connection Interrupted";
+	s = "Connection Interrupted"; // bk 010215 - FIXME
 	w = CG_DrawStrlen( s ) * BIGCHAR_WIDTH;
 	CG_DrawBigString( 320 - w/2, 100, s, 1.0F);
 
@@ -1638,6 +2132,7 @@
 	float	ax, ay, aw, ah, mid, range;
 	int		color;
 	float	vscale;
+	int totalSum;
 
 	if ( !cg_lagometer.integer || cgs.localServer ) {
 		CG_DrawDisconnect();
@@ -1736,6 +2231,14 @@
 		CG_DrawBigString( ax, ay, "snc", 1.0 );
 	}
 
+	CG_DrawBigString (x, y, va("%d", cg.snap->ping), 1.0);
+
+	for (totalSum = 0, i = 0;  i < LAG_SAMPLES  &&  i < lagometer.snapshotCount;  i++) {
+		totalSum += lagometer.snapshotSamples[(lagometer.snapshotCount - i) & (LAG_SAMPLES - 1)];
+    }
+
+	CG_DrawBigString (x, y + 20, va("%d  %d", totalSum / i, i), 1.0);
+
 	CG_DrawDisconnect();
 }
 
@@ -1787,20 +2290,25 @@
 	char	*start;
 	int		l;
 	int		x, y, w;
-#ifdef MISSIONPACK
-	int h;
+#ifdef MISSIONPACK // bk010221 - unused else
+  int h;
 #endif
 	float	*color;
 
+    //CG_Printf ("DrawCenterString: cg.centerPrintTime:%d\n", cg.centerPrintTime);
+
 	if ( !cg.centerPrintTime ) {
 		return;
 	}
 
+    //CG_Printf ("xxx\n");
+
 	color = CG_FadeColor( cg.centerPrintTime, 1000 * cg_centertime.value );
 	if ( !color ) {
 		return;
 	}
 
+    //CG_Printf ("drawing\n");
 	trap_R_SetColor( color );
 
 	start = cg.centerPrint;
@@ -1857,13 +2365,39 @@
 */
 
 
+static void Wolfcam_DrawCrosshair (void) 
+{
+    float w, h;
+    qhandle_t hShader;
+    float x, y;
+    int ca;
+
+    if (cg_entities[wcg.clientNum].currentState.eFlags & EF_DEAD)
+        return;
+
+    w = h = cg_crosshairSize.value;
+
+    x = cg_crosshairX.integer;
+    y = cg_crosshairY.integer;
+    CG_AdjustFrom640( &x, &y, &w, &h );
+
+    ca = cg_drawCrosshair.integer;
+    if (ca < 0) {
+        ca = 0;
+    }
+    hShader = cgs.media.crosshairShader[ ca % NUM_CROSSHAIRS ];
+
+    trap_R_DrawStretchPic( x + cg.refdef.x + 0.5 * (cg.refdef.width - w),
+                           y + cg.refdef.y + 0.5 * (cg.refdef.height - h),
+                           w, h, 0, 0, 1, 1, hShader );
+}
+
 /*
 =================
 CG_DrawCrosshair
 =================
 */
-static void CG_DrawCrosshair(void)
-{
+static void CG_DrawCrosshair(void) {
 	float		w, h;
 	qhandle_t	hShader;
 	float		f;
@@ -1874,11 +2408,16 @@
 		return;
 	}
 
+    if (wolfcam_following) {
+        Wolfcam_DrawCrosshair ();
+        return;
+    }
+
 	if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR) {
 		return;
 	}
 
-	if ( cg.renderingThirdPerson ) {
+	if (  cg.renderingThirdPerson ) {
 		return;
 	}
 
@@ -1917,82 +2456,6 @@
 		w, h, 0, 0, 1, 1, hShader );
 }
 
-/*
-=================
-CG_DrawCrosshair3D
-=================
-*/
-static void CG_DrawCrosshair3D(void)
-{
-	float		w, h;
-	qhandle_t	hShader;
-	float		f;
-	int			ca;
-
-	trace_t trace;
-	vec3_t endpos;
-	float stereoSep, zProj, maxdist, xmax;
-	char rendererinfos[128];
-	refEntity_t ent;
-
-	if ( !cg_drawCrosshair.integer ) {
-		return;
-	}
-
-	if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR) {
-		return;
-	}
-
-	if ( cg.renderingThirdPerson ) {
-		return;
-	}
-
-	w = h = cg_crosshairSize.value;
-
-	// pulse the size of the crosshair when picking up items
-	f = cg.time - cg.itemPickupBlendTime;
-	if ( f > 0 && f < ITEM_BLOB_TIME ) {
-		f /= ITEM_BLOB_TIME;
-		w *= ( 1 + f );
-		h *= ( 1 + f );
-	}
-
-	ca = cg_drawCrosshair.integer;
-	if (ca < 0) {
-		ca = 0;
-	}
-	hShader = cgs.media.crosshairShader[ ca % NUM_CROSSHAIRS ];
-
-	// Use a different method rendering the crosshair so players don't see two of them when
-	// focusing their eyes at distant objects with high stereo separation
-	// We are going to trace to the next shootable object and place the crosshair in front of it.
-
-	// first get all the important renderer information
-	trap_Cvar_VariableStringBuffer("r_zProj", rendererinfos, sizeof(rendererinfos));
-	zProj = atof(rendererinfos);
-	trap_Cvar_VariableStringBuffer("r_stereoSeparation", rendererinfos, sizeof(rendererinfos));
-	stereoSep = zProj / atof(rendererinfos);
-	
-	xmax = zProj * tan(cg.refdef.fov_x * M_PI / 360.0f);
-	
-	// let the trace run through until a change in stereo separation of the crosshair becomes less than one pixel.
-	maxdist = cgs.glconfig.vidWidth * stereoSep * zProj / (2 * xmax);
-	VectorMA(cg.refdef.vieworg, maxdist, cg.refdef.viewaxis[0], endpos);
-	CG_Trace(&trace, cg.refdef.vieworg, NULL, NULL, endpos, 0, MASK_SHOT);
-	
-	memset(&ent, 0, sizeof(ent));
-	ent.reType = RT_SPRITE;
-	ent.renderfx = RF_DEPTHHACK | RF_CROSSHAIR;
-	
-	VectorCopy(trace.endpos, ent.origin);
-	
-	// scale the crosshair so it appears the same size for all distances
-	ent.radius = w / 640 * xmax * trace.fraction * maxdist / zProj;
-	ent.customShader = hShader;
-
-	trap_R_AddRefEntityToScene(&ent);
-}
-
 
 
 /*
@@ -2014,6 +2477,8 @@
 		return;
 	}
 
+    //CG_Printf ("^2crosshairEnt: %d\n", trace.entityNum);  // wolfcam testing
+
 	// if the player is in fog, don't show it
 	content = trap_CM_PointContents( trace.endpos, 0 );
 	if ( content & CONTENTS_FOG ) {
@@ -2161,7 +2626,7 @@
 }
 
 
-static qboolean CG_DrawScoreboard( void ) {
+static qboolean CG_DrawScoreboard(void) {
 #ifdef MISSIONPACK
 	static qboolean firstTime = qtrue;
 	float fade, *fadeColor;
@@ -2311,6 +2776,7 @@
 }
 
 
+//FIXME maybe
 #ifdef MISSIONPACK
 /*
 =================
@@ -2416,6 +2882,8 @@
 			s = "Team Deathmatch";
 		} else if ( cgs.gametype == GT_CTF ) {
 			s = "Capture the Flag";
+		} else if ( cgs.gametype == GT_CA ) {
+			s = "Clan Arena";
 #ifdef MISSIONPACK
 		} else if ( cgs.gametype == GT_1FCTF ) {
 			s = "One Flag CTF";
@@ -2425,7 +2893,9 @@
 			s = "Harvester";
 #endif
 		} else {
-			s = "";
+			//s = "";
+			s = va("unknown: %d", cgs.gametype);
+			//Com_Printf("cgs.gametype: %d\n");
 		}
 #ifdef MISSIONPACK
 		w = CG_Text_Width(s, 0.6f, 0);
@@ -2517,8 +2987,7 @@
 CG_Draw2D
 =================
 */
-static void CG_Draw2D(stereoFrame_t stereoFrame)
-{
+static void CG_Draw2D( void ) {
 #ifdef MISSIONPACK
 	if (cgs.orderPending && cg.time > cgs.orderTime) {
 		CG_CheckOrderPending();
@@ -2545,12 +3014,12 @@
 */
 	if ( cg.snap->ps.persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
 		CG_DrawSpectator();
-
-		if(stereoFrame == STEREO_CENTER)
-			CG_DrawCrosshair();
-
+		CG_DrawCrosshair();
 		CG_DrawCrosshairNames();
-	} else {
+	} else if (wolfcam_following) {
+        Wolfcam_DrawStatusBar ();
+        Wolfcam_DrawCrosshair ();
+    } else {
 		// don't draw any status if dead or the scoreboard is being explicitly shown
 		if ( !cg.showScores && cg.snap->ps.stats[STAT_HEALTH] > 0 ) {
 
@@ -2568,8 +3037,7 @@
 #ifdef MISSIONPACK
 			CG_DrawProxWarning();
 #endif      
-			if(stereoFrame == STEREO_CENTER)
-				CG_DrawCrosshair();
+			CG_DrawCrosshair();
 			CG_DrawCrosshairNames();
 			CG_DrawWeaponSelect();
 
@@ -2595,10 +3063,10 @@
 
 #ifdef MISSIONPACK
 	if (!cg_paused.integer) {
-		CG_DrawUpperRight(stereoFrame);
+		CG_DrawUpperRight();
 	}
 #else
-	CG_DrawUpperRight(stereoFrame);
+	CG_DrawUpperRight();
 #endif
 
 #ifndef MISSIONPACK
@@ -2610,15 +3078,22 @@
 		CG_DrawWarmup();
 	}
 
-	// don't draw center string if scoreboard is up
-	cg.scoreBoardShowing = CG_DrawScoreboard();
+    if (!wolfcam_following) {
+        // don't draw center string if scoreboard is up
+        cg.scoreBoardShowing = CG_DrawScoreboard();
+    } else {
+        cg.scoreBoardShowing = qfalse;
+    }
+
 	if ( !cg.scoreBoardShowing) {
 		CG_DrawCenterString();
 	}
+
+    Wolfcam_DrawFollowing ();
 }
 
 
-static void CG_DrawTourneyScoreboard( void ) {
+static void CG_DrawTourneyScoreboard(void) {
 #ifdef MISSIONPACK
 #else
 	CG_DrawOldTourneyScoreboard();
@@ -2633,6 +3108,9 @@
 =====================
 */
 void CG_DrawActive( stereoFrame_t stereoView ) {
+	float		separation;
+	vec3_t		baseOrg;
+
 	// optionally draw the info screen instead
 	if ( !cg.snap ) {
 		CG_DrawInformation();
@@ -2646,17 +3124,41 @@
 		return;
 	}
 
+	switch ( stereoView ) {
+	case STEREO_CENTER:
+		separation = 0;
+		break;
+	case STEREO_LEFT:
+		separation = -cg_stereoSeparation.value / 2;
+		break;
+	case STEREO_RIGHT:
+		separation = cg_stereoSeparation.value / 2;
+		break;
+	default:
+		separation = 0;
+		CG_Error( "CG_DrawActive: Undefined stereoView" );
+	}
+
+
 	// clear around the rendered view if sized down
 	CG_TileClear();
 
-	if(stereoView != STEREO_CENTER)
-		CG_DrawCrosshair3D();
+	// offset vieworg appropriately if we're doing stereo separation
+	VectorCopy( cg.refdef.vieworg, baseOrg );
+	if ( separation != 0 ) {
+		VectorMA( cg.refdef.vieworg, -separation, cg.refdef.viewaxis[1], cg.refdef.vieworg );
+	}
 
 	// draw 3D view
 	trap_R_RenderScene( &cg.refdef );
 
+	// restore original viewpoint if running stereo
+	if ( separation != 0 ) {
+		VectorCopy( baseOrg, cg.refdef.vieworg );
+	}
+
 	// draw status bar and other floating elements
- 	CG_Draw2D(stereoView);
+ 	CG_Draw2D();
 }
 
 
diff -Naur cgame.orig/cg_drawtools.c cgame/cg_drawtools.c
--- cgame.orig/cg_drawtools.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_drawtools.c	2009-12-06 17:20:46.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_drawtools.c -- helper functions called by cg_draw, cg_scoreboard, cg_info, etc
 #include "cg_local.h"
@@ -431,6 +411,12 @@
 }
 
 
+
+
+// bk001205 - code below duplicated in q3_ui/ui-atoms.c
+// bk001205 - FIXME: does this belong in ui_shared.c?
+// bk001205 - FIXME: HARD_LINKED flags not visible here
+#ifndef Q3_STATIC // bk001205 - q_shared defines not visible here 
 /*
 =================
 UI_DrawProportionalString2
@@ -590,7 +576,7 @@
 static void UI_DrawBannerString2( int x, int y, const char* str, vec4_t color )
 {
 	const char* s;
-	unsigned char	ch;
+	unsigned char	ch; // bk001204 : array subscript
 	float	ax;
 	float	ay;
 	float	aw;
@@ -604,7 +590,7 @@
 	trap_R_SetColor( color );
 	
 	ax = x * cgs.screenXScale + cgs.screenXBias;
-	ay = y * cgs.screenXScale;
+	ay = y * cgs.screenYScale;
 
 	s = str;
 	while ( *s )
@@ -700,7 +686,7 @@
 static void UI_DrawProportionalString2( int x, int y, const char* str, vec4_t color, float sizeScale, qhandle_t charset )
 {
 	const char* s;
-	unsigned char	ch;
+	unsigned char	ch; // bk001204 - unsigned
 	float	ax;
 	float	ay;
 	float	aw;
@@ -714,7 +700,7 @@
 	trap_R_SetColor( color );
 	
 	ax = x * cgs.screenXScale + cgs.screenXBias;
-	ay = y * cgs.screenYScale;
+	ay = y * cgs.screenXScale;
 
 	s = str;
 	while ( *s )
@@ -815,3 +801,4 @@
 
 	UI_DrawProportionalString2( x, y, str, color, sizeScale, cgs.media.charsetProp );
 }
+#endif // Q3STATIC
diff -Naur cgame.orig/cg_effects.c cgame/cg_effects.c
--- cgame.orig/cg_effects.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_effects.c	2009-12-02 16:24:59.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_effects.c -- these functions generate localentities, usually as a result
 // of event processing
@@ -187,14 +167,14 @@
 	re->reType = RT_MODEL;
 	re->shaderTime = cg.time / 1000.0f;
 
-#ifndef MISSIONPACK
+#if  0  //ndef MPACK
 	re->customShader = cgs.media.teleportEffectShader;
 #endif
 	re->hModel = cgs.media.teleportEffectModel;
 	AxisClear( re->axis );
 
 	VectorCopy( org, re->origin );
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	re->origin[2] += 16;
 #else
 	re->origin[2] -= 24;
@@ -202,7 +182,7 @@
 }
 
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 /*
 ===============
 CG_LightningBoltBeam
@@ -377,7 +357,7 @@
 	trap_S_StartSound (org, ENTITYNUM_NONE, CHAN_BODY, cgs.media.invulnerabilityJuicedSound );
 }
 
-#endif
+#endif  // if 1  MPACK
 
 /*
 ==================
diff -Naur cgame.orig/cg_ents.c cgame/cg_ents.c
--- cgame.orig/cg_ents.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_ents.c	2009-12-05 21:55:16.000000000 -0500
@@ -1,29 +1,9 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_ents.c -- present snapshot entities, happens every single frame
 
 #include "cg_local.h"
-
+#include "wolfcam_local.h"
 
 /*
 ======================
@@ -132,8 +112,11 @@
 			trap_S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, 
 				cgs.gameSounds[ cent->currentState.loopSound ] );
 		} else {
+			//FIXME this is wrong
+#if 0
 			trap_S_AddRealLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, 
 				cgs.gameSounds[ cent->currentState.loopSound ] );
+#endif
 		}
 	}
 
@@ -234,7 +217,9 @@
 
 	es = &cent->currentState;
 	if ( es->modelindex >= bg_numItems ) {
-		CG_Error( "Bad item index %i on entity", es->modelindex );
+		//CG_Error( "Bad item index %i on entity", es->modelindex );
+		CG_Printf( "Bad item index %i on entity\n", es->modelindex );
+        //return;
 	}
 
 	// if set to invisible, skip
@@ -326,12 +311,12 @@
 		VectorScale( ent.axis[1], 1.5, ent.axis[1] );
 		VectorScale( ent.axis[2], 1.5, ent.axis[2] );
 		ent.nonNormalizedAxes = qtrue;
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK  //FIXME check a demo
 		trap_S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, cgs.media.weaponHoverSound );
 #endif
 	}
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	if ( item->giType == IT_HOLDABLE && item->giTag == HI_KAMIKAZE ) {
 		VectorScale( ent.axis[0], 2, ent.axis[0] );
 		VectorScale( ent.axis[1], 2, ent.axis[1] );
@@ -343,7 +328,7 @@
 	// add to refresh list
 	trap_R_AddRefEntityToScene(&ent);
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	if ( item->giType == IT_WEAPON && wi->barrelModel ) {
 		refEntity_t	barrel;
 
@@ -473,7 +458,7 @@
 	ent.hModel = weapon->missileModel;
 	ent.renderfx = weapon->missileRenderfx | RF_NOSHADOW;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	if ( cent->currentState.weapon == WP_PROX_LAUNCHER ) {
 		if (s1->generic1 == TEAM_BLUE) {
 			ent.hModel = cgs.media.blueProxMine;
@@ -490,7 +475,7 @@
 	if ( s1->pos.trType != TR_STATIONARY ) {
 		RotateAroundDirection( ent.axis, cg.time / 4 );
 	} else {
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		if ( s1->weapon == WP_PROX_LAUNCHER ) {
 			AnglesToAxis( cent->lerpAngles, ent.axis );
 		}
@@ -702,6 +687,10 @@
 	vec3_t		current, next;
 	float		f;
 
+	if (Wolfcam_InterpolateEntityPosition(cent)) {
+		return;
+	}
+
 	// it would be an internal error to find an entity that interpolates without
 	// a snapshot ahead of the current one
 	if ( cg.nextSnap == NULL ) {
@@ -1031,7 +1020,16 @@
 	// add each entity sent over by the server
 	for ( num = 0 ; num < cg.snap->numEntities ; num++ ) {
 		cent = &cg_entities[ cg.snap->entities[ num ].number ];
-		CG_AddCEntity( cent );
+        if (!wolfcam_following)
+            CG_AddCEntity( cent );
+        else {
+            if (wcg.clientNum == cg.snap->entities[num].number) {
+                cent->currentState.eFlags |= EF_NODRAW;
+                cent->nextState.eFlags |= EF_NODRAW;
+            }
+                
+            CG_AddCEntity( cent );
+        }
 	}
 }
 
diff -Naur cgame.orig/cg_event.c cgame/cg_event.c
--- cgame.orig/cg_event.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_event.c	2009-12-05 22:00:31.000000000 -0500
@@ -1,31 +1,13 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_event.c -- handle entity events at snapshot or playerstate transitions
 
 #include "cg_local.h"
+#include "wolfcam_local.h"
+//#include <stdio.h>
 
 // for the voice chats
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK // bk001205
 #include "../../ui/menudef.h"
 #endif
 //==========================================================================
@@ -95,6 +77,16 @@
 	attacker = ent->otherEntityNum2;
 	mod = ent->eventParm;
 
+    if (attacker >= 0  &&  attacker <= MAX_CLIENTS) {
+        if (attacker == target)
+            wclients[attacker].suicides++;
+        else
+            wclients[attacker].kills++;
+    }
+    if (target >= 0  &&  target <= MAX_CLIENTS) {
+            wclients[target].deaths++;
+    }
+
 	if ( target < 0 || target >= MAX_CLIENTS ) {
 		CG_Error( "CG_Obituary: target out of range" );
 	}
@@ -151,7 +143,7 @@
 	if (attacker == target) {
 		gender = ci->gender;
 		switch (mod) {
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		case MOD_KAMIKAZE:
 			message = "goes out with a bang";
 			break;
@@ -163,6 +155,7 @@
 				message = "tripped on its own grenade";
 			else
 				message = "tripped on his own grenade";
+            wclients[attacker].wstats[WP_GRENADE_LAUNCHER].suicides++;
 			break;
 		case MOD_ROCKET_SPLASH:
 			if ( gender == GENDER_FEMALE )
@@ -171,6 +164,7 @@
 				message = "blew itself up";
 			else
 				message = "blew himself up";
+            wclients[attacker].wstats[WP_ROCKET_LAUNCHER].suicides++;
 			break;
 		case MOD_PLASMA_SPLASH:
 			if ( gender == GENDER_FEMALE )
@@ -179,11 +173,13 @@
 				message = "melted itself";
 			else
 				message = "melted himself";
+            wclients[attacker].wstats[WP_PLASMAGUN].suicides++;
 			break;
 		case MOD_BFG_SPLASH:
 			message = "should have used a smaller gun";
+            wclients[attacker].wstats[WP_BFG].suicides++;
 			break;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		case MOD_PROXIMITY_MINE:
 			if( gender == GENDER_FEMALE ) {
 				message = "found her prox mine";
@@ -203,7 +199,56 @@
 				message = "killed himself";
 			break;
 		}
-	}
+	} else {
+        if ((attacker >= 0  &&  attacker <= MAX_CLIENTS)  &&
+            (target >= 0  &&  target <= MAX_CLIENTS))
+        {
+            switch (mod) {
+            case MOD_GAUNTLET:
+                wclients[attacker].wstats[WP_GAUNTLET].kills++;
+                wclients[target].wstats[WP_GAUNTLET].deaths++;
+                break;
+            case MOD_MACHINEGUN:
+                wclients[attacker].wstats[WP_MACHINEGUN].kills++;
+                wclients[target].wstats[WP_MACHINEGUN].deaths++;
+                break;
+            case MOD_SHOTGUN:
+                wclients[attacker].wstats[WP_SHOTGUN].kills++;
+                wclients[target].wstats[WP_SHOTGUN].deaths++;
+                break;
+            case MOD_GRENADE:
+            case MOD_GRENADE_SPLASH:
+                wclients[attacker].wstats[WP_GRENADE_LAUNCHER].kills++;
+                wclients[target].wstats[WP_GRENADE_LAUNCHER].deaths++;
+                break;
+            case MOD_ROCKET:
+            case MOD_ROCKET_SPLASH:
+                wclients[attacker].wstats[WP_ROCKET_LAUNCHER].kills++;
+                wclients[target].wstats[WP_ROCKET_LAUNCHER].deaths++;
+                break;
+            case MOD_PLASMA:
+            case MOD_PLASMA_SPLASH:
+                wclients[attacker].wstats[WP_PLASMAGUN].kills++;
+                wclients[target].wstats[WP_PLASMAGUN].deaths++;
+                break;
+            case MOD_RAILGUN:
+                wclients[attacker].wstats[WP_RAILGUN].kills++;
+                wclients[target].wstats[WP_RAILGUN].deaths++;
+                break;
+            case MOD_LIGHTNING:
+                wclients[attacker].wstats[WP_LIGHTNING].kills++;
+                wclients[target].wstats[WP_LIGHTNING].deaths++;
+                break;
+            case MOD_BFG:
+            case MOD_BFG_SPLASH:
+                wclients[attacker].wstats[WP_BFG].kills++;
+                wclients[target].wstats[WP_BFG].deaths++;
+                break;
+            default:
+                break;
+            }
+        }
+    }
 
 	if (message) {
 		CG_Printf( "%s %s.\n", targetName, message);
@@ -211,7 +256,7 @@
 	}
 
 	// check for kill messages from the current clientNum
-	if ( attacker == cg.snap->ps.clientNum ) {
+	if ( !wolfcam_following  &&  attacker == cg.snap->ps.clientNum ) {
 		char	*s;
 
 		if ( cgs.gametype < GT_TEAM ) {
@@ -230,7 +275,13 @@
 #endif
 
 		// print the text message as well
-	}
+	} else if (wolfcam_following) {
+        if (attacker == wcg.clientNum) {
+            char *s;
+            s = va("You fragged %s", targetName);
+            CG_CenterPrint (s, SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH);
+        }
+    }
 
 	// check for double client messages
 	if ( !attackerInfo ) {
@@ -294,7 +345,7 @@
 			message = "was blasted by";
 			message2 = "'s BFG";
 			break;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		case MOD_NAIL:
 			message = "was nailed by";
 			break;
@@ -355,15 +406,22 @@
 	}
 
 	// print a message if the local player
-	if ( es->number == cg.snap->ps.clientNum ) {
+	if ( !wolfcam_following  &&  es->number == cg.snap->ps.clientNum ) {
 		if ( !itemNum ) {
 			CG_CenterPrint( "No item to use", SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH );
 		} else {
 			item = BG_FindItemForHoldable( itemNum );
 			CG_CenterPrint( va("Use %s", item->pickup_name), SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH );
 		}
-	}
-
+	} else if (wolfcam_following  &&  es->number == wcg.clientNum) {
+        if ( !itemNum ) {
+            CG_CenterPrint( "No item to use", SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH );
+        } else {
+            item = BG_FindItemForHoldable( itemNum );
+            CG_CenterPrint( va("Use %s", item->pickup_name), SCREEN_HEIGHT * 0.30, BIGCHAR_WIDTH );                         
+        }
+    }
+    
 	switch ( itemNum ) {
 	default:
 	case HI_NONE:
@@ -382,7 +440,7 @@
 		trap_S_StartSound (NULL, es->number, CHAN_BODY, cgs.media.medkitSound );
 		break;
 
-#ifdef MISSIONPACK
+#if  1  //def MPACK
 	case HI_KAMIKAZE:
 		break;
 
@@ -488,6 +546,8 @@
 	}
 	ci = &cgs.clientinfo[ clientNum ];
 
+    wolfcam_log_event (cent, position);
+
 	switch ( event ) {
 	//
 	// movement generated events
@@ -506,6 +566,13 @@
 				cgs.media.footsteps[ FOOTSTEP_METAL ][rand()&3] );
 		}
 		break;
+	case EV_FOOTSTEP_WOOD:
+		DEBUGNAME("EV_FOOTSTEP_WOOD");
+		if (cg_footsteps.integer) {
+			trap_S_StartSound (NULL, es->number, CHAN_BODY, 
+				cgs.media.footsteps[ FOOTSTEP_WOOD ][rand()&3] );
+		}
+		break;
 	case EV_FOOTSPLASH:
 		DEBUGNAME("EV_FOOTSPLASH");
 		if (cg_footsteps.integer) {
@@ -686,7 +753,7 @@
 			if ( item->giType == IT_POWERUP || item->giType == IT_TEAM) {
 				trap_S_StartSound (NULL, es->number, CHAN_AUTO,	cgs.media.n_healthSound );
 			} else if (item->giType == IT_PERSISTANT_POWERUP) {
-#ifdef MISSIONPACK
+#if  1  //def MPACK
 				switch (item->giTag ) {
 					case PW_SCOUT:
 						trap_S_StartSound (NULL, es->number, CHAN_AUTO,	cgs.media.scoutSound );
@@ -707,9 +774,10 @@
 			}
 
 			// show icon and name on status bar
-			if ( es->number == cg.snap->ps.clientNum ) {
+			if ( !wolfcam_following  &&  es->number == cg.snap->ps.clientNum ) {
 				CG_ItemPickup( index );
 			}
+            //FIXME wolfcam wolfcam_following
 		}
 		break;
 
@@ -731,9 +799,10 @@
 			}
 
 			// show icon and name on status bar
-			if ( es->number == cg.snap->ps.clientNum ) {
+			if ( !wolfcam_following  &&  es->number == cg.snap->ps.clientNum ) {
 				CG_ItemPickup( index );
 			}
+            //FIXME wolfcam wolfcam_following
 		}
 		break;
 
@@ -743,19 +812,29 @@
 	case EV_NOAMMO:
 		DEBUGNAME("EV_NOAMMO");
 //		trap_S_StartSound (NULL, es->number, CHAN_AUTO, cgs.media.noAmmoSound );
-		if ( es->number == cg.snap->ps.clientNum ) {
+		if ( !wolfcam_following  &&  es->number == cg.snap->ps.clientNum ) {
 			CG_OutOfAmmoChange();
 		}
+        //FIXME wolfcam wolfcam_following
 		break;
 	case EV_CHANGE_WEAPON:
 		DEBUGNAME("EV_CHANGE_WEAPON");
 		trap_S_StartSound (NULL, es->number, CHAN_AUTO, cgs.media.selectSound );
 		break;
-	case EV_FIRE_WEAPON:
+	case EV_FIRE_WEAPON: {
+        //char buffer[4192];
+        //char *s;
+
 		DEBUGNAME("EV_FIRE_WEAPON");
+#if 0
+        s = va("EV_FIRE_WEAPON: %d %d %s\n", clientNum, es->weapon, cgs.clientinfo[clientNum].name);
+        Q_strncpyz(buffer, s, sizeof(buffer));  //strcpy (buffer, s);
+        //CG_Printf ("wc_logfile: %d\n", wc_logfile);
+        trap_FS_Write (buffer, strlen(buffer), wc_logfile);
+#endif
 		CG_FireWeapon( cent );
 		break;
-
+    }
 	case EV_USE_ITEM0:
 		DEBUGNAME("EV_USE_ITEM0");
 		CG_UseItem( cent );
@@ -853,7 +932,7 @@
 		}
 		break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case EV_PROXIMITY_MINE_STICK:
 		DEBUGNAME("EV_PROXIMITY_MINE_STICK");
 		if( es->eventParm & SURF_FLESH ) {
@@ -904,8 +983,12 @@
 	//
 	case EV_MISSILE_HIT:
 		DEBUGNAME("EV_MISSILE_HIT");
+        //CG_Printf ("%d %d %d %d %d %d [%d] missile hit\n", clientNum, es->number, es->clientNum, es->otherEntityNum2, es->time, es->time2, es->otherEntityNum);
 		ByteToDir( es->eventParm, dir );
 		CG_MissileHitPlayer( es->weapon, position, dir, es->otherEntityNum );
+        //wclients[clientNum].wstats[es->weapon].hits++;
+        //FIXME wolfcam put in wolfcam_event.c
+        Wolfcam_LogMissileHit (es->weapon, position, dir, es->otherEntityNum);
 		break;
 
 	case EV_MISSILE_MISS:
@@ -923,22 +1006,67 @@
 	case EV_RAILTRAIL:
 		DEBUGNAME("EV_RAILTRAIL");
 		cent->currentState.weapon = WP_RAILGUN;
-		
-		if(es->clientNum == cg.snap->ps.clientNum && !cg.renderingThirdPerson)
-		{
-			if(cg_drawGun.integer == 2)
-				VectorMA(es->origin2, 8, cg.refdef.viewaxis[1], es->origin2);
-			else if(cg_drawGun.integer == 3)
-				VectorMA(es->origin2, 4, cg.refdef.viewaxis[1], es->origin2);
-		}
-
-		CG_RailTrail(ci, es->origin2, es->pos.trBase);
-
 		// if the end was on a nomark surface, don't make an explosion
+		CG_RailTrail( ci, es->origin2, es->pos.trBase );
 		if ( es->eventParm != 255 ) {
 			ByteToDir( es->eventParm, dir );
 			CG_MissileHitWall( es->weapon, es->clientNum, position, dir, IMPACTSOUND_DEFAULT );
 		}
+
+#if 1
+        //if (wolfcam_following)  //  &&  wcg.clientNum == clientNum)
+        {
+            trace_t tr;
+            vec3_t or;
+            vec3_t forward, right, up;
+            vec3_t newEnd;
+            vec3_t trBase;
+            vec3_t oldTrBase;
+            vec3_t nextTrBase;
+
+            VectorCopy (es->origin2, or);
+            
+            if (clientNum == cg.snap->ps.clientNum) {
+                AngleVectors (cg.snap->ps.viewangles, forward, right, up);
+                VectorCopy (cg.snap->ps.origin, trBase);
+                VectorCopy (wclients[clientNum].oldState.pos.trBase, oldTrBase);
+                VectorCopy (cg_entities[clientNum].nextState.pos.trBase, nextTrBase);
+            } else {
+                AngleVectors (cg_entities[clientNum].currentState.apos.trBase, forward, right, up);
+                VectorCopy (cg_entities[clientNum].currentState.pos.trBase, trBase);
+                VectorCopy (wclients[clientNum].oldState.pos.trBase, oldTrBase);
+                VectorCopy (cg_entities[clientNum].nextState.pos.trBase, nextTrBase);
+            }
+            VectorMA (or, 1, up, or);
+            VectorMA (or, -4, right, or);
+
+            VectorMA (or, 131072, forward, newEnd);
+#if 0
+            if (wolfcam_following  &&  clientNum == wcg.clientNum) {
+                CG_Printf ("EV_RAILTRAIL: %d  es->origin2 (%f, %f, %f)  or (%f, %f, %f)  pos.trBase (%f, %f, %f)  old.pos.trBase (%f, %f, %f)  %s\n",
+                           clientNum,
+                           es->origin2[0], es->origin2[1], es->origin2[2],
+                           or[0], or[1], or[2],
+                           trBase[0], trBase[1], trBase[2],
+                           oldTrBase[0], oldTrBase[1], oldTrBase[2],
+                           //nextTrBase[0], nextTrBase[1], nextTrBase[2],
+                           cgs.clientinfo[clientNum].name);
+            }
+#endif
+
+            //            Wolfcam_WeaponTrace (&tr, or /*es->origin2*/, NULL, NULL, es->pos.trBase, clientNum, CONTENTS_SOLID | CONTENTS_BODY);
+            //Wolfcam_WeaponTrace (&tr, or /*es->origin2*/, NULL, NULL, newEnd, clientNum, CONTENTS_SOLID | CONTENTS_BODY);
+            Wolfcam_WeaponTrace (&tr, or /*es->origin2*/, NULL, NULL, es->pos.trBase, clientNum, CONTENTS_SOLID | CONTENTS_BODY);
+            if (tr.entityNum < MAX_CLIENTS) {
+                //CG_Printf ("  ^3xxxx hit %d  %s\n", tr.entityNum, cgs.clientinfo[tr.entityNum].name);
+                wclients[clientNum].wstats[WP_RAILGUN].hits++;
+                if (wolfcam_following  &&  clientNum == wcg.clientNum) {
+                    //CG_Printf ("  ^3xxxx hit %d  %s\n", tr.entityNum, cgs.clientinfo[tr.entityNum].name);
+                    wcg.playHitSound = qtrue;
+                }
+            }
+        }
+#endif
 		break;
 
 	case EV_BULLET_HIT_WALL:
@@ -949,37 +1077,99 @@
 
 	case EV_BULLET_HIT_FLESH:
 		DEBUGNAME("EV_BULLET_HIT_FLESH");
+        wclients[es->otherEntityNum].wstats[WP_MACHINEGUN].hits++;
+        if (wolfcam_following) {
+            if (es->otherEntityNum == wcg.clientNum) {
+                //CG_Printf ("hitting  %d!!!\n", es->weapon);
+                //trap_S_StartLocalSound( cgs.media.hitSound, CHAN_LOCAL_SOUND);
+                wcg.playHitSound = qtrue;
+            }
+                
+        }
+        if ((cg_entities[es->otherEntityNum].currentValid  ||  cg.snap->ps.clientNum == es->otherEntityNum)  &&  (cg_entities[es->eventParm].currentValid  ||  cg.snap->ps.clientNum == es->eventParm))
+        {
+            vec3_t vec, enemyvec, angs;
+            //entityState_t *e = &cg_entities[es->otherEntityNum].currentState;
+            //static FILE *datafile = NULL;
+
+            //if (!datafile) {
+            //    fopen ("/tmp/shotdata.txt", "w");
+            //}
+
+            VectorCopy (cg_entities[es->eventParm].lerpOrigin, enemyvec);
+            //FIXME ducked
+            VectorSubtract (enemyvec, cg_entities[es->otherEntityNum].lerpOrigin, vec);
+            vectoangles (vec, angs);
+            //CG_Printf ("angs: %f %f ^3%f ^3%f\n", angs[0], angs[1], cg_entities[es->otherEntityNum].lerpAngles[0] - angs[0], cg_entities[es->otherEntityNum].lerpAngles[1] - angs[1]);
+            //fprintf (datafile, "%d %s\n", es->otherEntityNum, cgs.clientinfo[es->otherEntityNum].name);
+            //fprintf (datafile, "%f %f\n", cg_entities[es->otherEntityNum].lerpAngles[0] - angs[0], cg_entities[es->otherEntityNum].lerpAngles[1] - angs[1]);
+
+#if 0
+            CG_Printf ("EV_BULLET_HIT_FLESH: %d %s\n", es->otherEntityNum, cgs.clientinfo[es->otherEntityNum].name);
+            CG_Printf ("%f %f\n", cg_entities[es->otherEntityNum].lerpAngles[0] - angs[0], cg_entities[es->otherEntityNum].lerpAngles[1] - angs[1]);
+#endif
+
+#if 0
+            CG_Printf ("EV_BULLET_HIT_FLESH: %d  time:%d  time2:%d  snapnum:%d  cg.time:%d  %s\n", es->otherEntityNum, es->time, es->time2, cgs.processedSnapshotNum, cg.time, cgs.clientinfo[es->otherEntityNum].name);
+            CG_Printf ("    (%f %f %f)  (%f %f %f)\n",
+                       e->pos.trBase[0], e->pos.trBase[1], e->pos.trBase[2],
+                       e->apos.trBase[0], e->apos.trBase[1], e->apos.trBase[2]);
+            CG_Printf ("    (%f %f %f)  (%f %f %f)\n",
+                       cg_entities[es->otherEntityNum].lerpOrigin[0], cg_entities[es->otherEntityNum].lerpOrigin[1], cg_entities[es->otherEntityNum].lerpOrigin[2],
+                       cg_entities[es->otherEntityNum].lerpAngles[0], cg_entities[es->otherEntityNum].lerpAngles[1], cg_entities[es->otherEntityNum].lerpAngles[2]
+                       );
+#endif
+        }
 		CG_Bullet( es->pos.trBase, es->otherEntityNum, dir, qtrue, es->eventParm );
 		break;
 
 	case EV_SHOTGUN:
 		DEBUGNAME("EV_SHOTGUN");
 		CG_ShotgunFire( es );
+        //CG_Printf ("EV_SHOTGUN: es->otherEntityNum: %d %s\n", es->otherEntityNum, cgs.clientinfo[es->otherEntityNum].name);
 		break;
 
 	case EV_GENERAL_SOUND:
 		DEBUGNAME("EV_GENERAL_SOUND");
-		if ( cgs.gameSounds[ es->eventParm ] ) {
+		//CG_Printf("EV_GENERAL_SOUND %d\n", es->eventParm);
+		if (es->eventParm == 0) {
+			Com_Printf("FIXME EV_GENERAL_SOUND eventParm == 0\n");
+		}
+
+		if ( cgs.gameSounds[ es->eventParm ] )  {  //- 1 ] ) {
 			trap_S_StartSound (NULL, es->number, CHAN_VOICE, cgs.gameSounds[ es->eventParm ] );
 		} else {
-			s = CG_ConfigString( CS_SOUNDS + es->eventParm );
-			trap_S_StartSound (NULL, es->number, CHAN_VOICE, CG_CustomSound( es->number, s ) );
+			//s = CG_ConfigString( CS_SOUNDS + es->eventParm );
+			s = CG_ConfigString( CS_SOUNDS + es->eventParm + 1);  //- 1);  //FIXME testing
+			CG_Printf("FIXME EV_GENERAL_SOUND (eventParm %d)  '%s'\n", es->eventParm, s);
+			if (!s  ||  !s[0]) {
+				CG_Printf("  skipping\n");
+			} else {
+				trap_S_StartSound (NULL, es->number, CHAN_VOICE, CG_CustomSound( es->number, s ) );
+			}
 		}
 		break;
 
 	case EV_GLOBAL_SOUND:	// play from the player's head so it never diminishes
 		DEBUGNAME("EV_GLOBAL_SOUND");
 		if ( cgs.gameSounds[ es->eventParm ] ) {
-			trap_S_StartSound (NULL, cg.snap->ps.clientNum, CHAN_AUTO, cgs.gameSounds[ es->eventParm ] );
+            if (!wolfcam_following)
+                trap_S_StartSound (NULL, cg.snap->ps.clientNum, CHAN_AUTO, cgs.gameSounds[ es->eventParm ] );
+            else
+                trap_S_StartSound (NULL, wcg.clientNum, CHAN_AUTO, cgs.gameSounds[es->eventParm]);
 		} else {
 			s = CG_ConfigString( CS_SOUNDS + es->eventParm );
-			trap_S_StartSound (NULL, cg.snap->ps.clientNum, CHAN_AUTO, CG_CustomSound( es->number, s ) );
+            if (!wolfcam_following)
+                trap_S_StartSound (NULL, cg.snap->ps.clientNum, CHAN_AUTO, CG_CustomSound( es->number, s ) );
+            else
+                trap_S_StartSound (NULL, wcg.clientNum, CHAN_AUTO, CG_CustomSound(es->number, s));
 		}
 		break;
 
 	case EV_GLOBAL_TEAM_SOUND:	// play from the player's head so it never diminishes
 		{
 			DEBUGNAME("EV_GLOBAL_TEAM_SOUND");
+            //FIXME wolfcam 
 			switch( es->eventParm ) {
 				case GTS_RED_CAPTURE: // CTF: red team captured the blue flag, 1FCTF: red team captured the neutral flag
 					if ( cgs.clientinfo[cg.clientNum].team == TEAM_RED )
@@ -1082,7 +1272,7 @@
 				case GTS_TEAMS_ARE_TIED:
 					CG_AddBufferedSound( cgs.media.teamsTiedSound );
 					break;
-#ifdef MISSIONPACK
+#if  1  //def MISSIONPACK
 				case GTS_KAMIKAZE:
 					trap_S_StartLocalSound(cgs.media.kamikazeFarSound, CHAN_ANNOUNCER);
 					break;
@@ -1096,6 +1286,7 @@
 	case EV_PAIN:
 		// local player sounds are triggered in CG_CheckLocalSounds,
 		// so ignore events on the player
+        //FIXME wolfcam
 		DEBUGNAME("EV_PAIN");
 		if ( cent->currentState.number != cg.snap->ps.clientNum ) {
 			CG_PainEvent( cent, es->eventParm );
@@ -1166,11 +1357,24 @@
 		CG_Beam( cent );
 		break;
 
-	default:
+	case EV_OVERTIME:
+	case EV_GAMEOVER: {
+		//FIXME
+		break;
+	}
+
+	default: {
+		static int lastUnknownEvent = 0;
+
 		DEBUGNAME("UNKNOWN");
-		CG_Error( "Unknown event: %i", event );
+		//CG_Error( "Unknown event: %i", event );
+		if (event != lastUnknownEvent) {
+			CG_Printf ("Unknown event: %i\n", event);
+			lastUnknownEvent = event;
+		}
 		break;
 	}
+	}
 
 }
 
diff -Naur cgame.orig/cg_info.c cgame/cg_info.c
--- cgame.orig/cg_info.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_info.c	2009-12-02 15:20:10.000000000 -0500
@@ -1,28 +1,9 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_info.c -- display information while data is being loading
 
 #include "cg_local.h"
+#include "wolfcam_local.h"
 
 #define MAX_LOADING_PLAYER_ICONS	16
 #define MAX_LOADING_ITEM_ICONS		26
@@ -183,6 +164,8 @@
 			UI_CENTER|UI_SMALLFONT|UI_DROPSHADOW, colorWhite );
 	}
 
+    UI_DrawProportionalString (0, 0, "wolfcam-quakelive version " WOLFCAM_VERSION,
+                               UI_SMALLFONT|UI_DROPSHADOW, colorYellow);
 	// draw info string information
 
 	y = 180-32;
@@ -247,6 +230,9 @@
 	case GT_TEAM:
 		s = "Team Deathmatch";
 		break;
+	case GT_CA:
+		s = "Clan Arena";
+		break;
 	case GT_CTF:
 		s = "Capture The Flag";
 		break;
diff -Naur cgame.orig/cg_localents.c cgame/cg_localents.c
--- cgame.orig/cg_localents.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_localents.c	2009-12-02 17:16:45.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 
 // cg_localents.c -- every frame, generate renderer commands for locally
@@ -536,7 +516,7 @@
 }
 
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 /*
 ====================
 CG_AddKamikaze
@@ -863,7 +843,7 @@
 			CG_AddScorePlum( le );
 			break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		case LE_KAMIKAZE:
 			CG_AddKamikaze( le );
 			break;
diff -Naur cgame.orig/cg_local.h cgame/cg_local.h
--- cgame.orig/cg_local.h	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_local.h	2009-12-06 17:10:40.000000000 -0500
@@ -1,37 +1,17 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 #include "../qcommon/q_shared.h"
 #include "../renderer/tr_types.h"
 #include "../game/bg_public.h"
 #include "cg_public.h"
-
+#include "sc.h"
 
 // The entire cgame module is unloaded and reloaded on each level change,
 // so there is NO persistant data between levels on the client side.
 // If you absolutely need something stored, it can either be kept
 // by the server in the server stored userinfos, or stashed in a cvar.
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 #define CG_FONT_THRESHOLD 0.1
 #endif
 
@@ -103,6 +83,7 @@
 	FOOTSTEP_ENERGY,
 	FOOTSTEP_METAL,
 	FOOTSTEP_SPLASH,
+	FOOTSTEP_WOOD,
 
 	FOOTSTEP_TOTAL
 } footstep_t;
@@ -226,7 +207,7 @@
 	LE_FADE_RGB,
 	LE_SCALE_FADE,
 	LE_SCOREPLUM,
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	LE_KAMIKAZE,
 	LE_INVULIMPACT,
 	LE_INVULJUICED,
@@ -301,6 +282,11 @@
 	int				captures;
 	qboolean	perfect;
 	int				team;
+
+	int				unk1;
+	int				unk2;
+	int				unk3;
+
 } score_t;
 
 // each client has an associated clientInfo_t
@@ -741,7 +727,7 @@
 	qhandle_t	plasmaBallShader;
 	qhandle_t	waterBubbleShader;
 	qhandle_t	bloodTrailShader;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	qhandle_t	nailPuffShader;
 	qhandle_t	blueProxMine;
 #endif
@@ -790,7 +776,7 @@
 	// special effects models
 	qhandle_t	teleportEffectModel;
 	qhandle_t	teleportEffectShader;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	qhandle_t	kamikazeEffectModel;
 	qhandle_t	kamikazeShockWave;
 	qhandle_t	kamikazeHeadModel;
@@ -837,7 +823,7 @@
 	sfxHandle_t	sfx_railg;
 	sfxHandle_t	sfx_rockexp;
 	sfxHandle_t	sfx_plasmaexp;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	sfxHandle_t	sfx_proxexp;
 	sfxHandle_t	sfx_nghit;
 	sfxHandle_t	sfx_nghitflesh;
@@ -946,7 +932,7 @@
 	sfxHandle_t	countFightSound;
 	sfxHandle_t	countPrepareSound;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	// new stuff
 	qhandle_t patrolShader;
 	qhandle_t assaultShader;
@@ -1040,6 +1026,7 @@
 	vec3_t			inlineModelMidpoints[MAX_MODELS];
 
 	clientInfo_t	clientinfo[MAX_CLIENTS];
+	clientInfo_t	clientinfoOrig[MAX_CLIENTS];
 
 	// teamchat width is *3 because of embedded color codes
 	char			teamChatMsgs[TEAMCHAT_HEIGHT][TEAMCHAT_WIDTH*3+1];
@@ -1068,6 +1055,7 @@
 	// media
 	cgMedia_t		media;
 
+    qboolean fKeyPressed[256];  // Key status to get around console issues
 } cgs_t;
 
 //==============================================================================
@@ -1079,6 +1067,12 @@
 extern	itemInfo_t		cg_items[MAX_ITEMS];
 extern	markPoly_t		cg_markPolys[MAX_MARK_POLYS];
 
+extern clientInfo_t		EM_ModelInfo;
+extern int				EM_Loaded;
+extern byte				EC_Colors[3][4];
+extern int				EC_Loaded;
+extern char    			*cg_customSoundNames[MAX_CUSTOM_SOUNDS];
+
 extern	vmCvar_t		cg_centertime;
 extern	vmCvar_t		cg_runpitch;
 extern	vmCvar_t		cg_runroll;
@@ -1134,6 +1128,7 @@
 extern	vmCvar_t		cg_thirdPersonRange;
 extern	vmCvar_t		cg_thirdPersonAngle;
 extern	vmCvar_t		cg_thirdPerson;
+extern	vmCvar_t		cg_stereoSeparation;
 extern	vmCvar_t		cg_lagometer;
 extern	vmCvar_t		cg_drawAttacker;
 extern	vmCvar_t		cg_synchronousClients;
@@ -1183,6 +1178,11 @@
 extern	vmCvar_t		cg_obeliskRespawnDelay;
 #endif
 
+extern vmCvar_t cg_drawSpeed;
+
+extern vmCvar_t wolfcam_enemyModel;
+extern vmCvar_t wolfcam_enemyColors;
+
 //
 // cg_main.c
 //
@@ -1204,8 +1204,8 @@
 void CG_EventHandling(int type);
 void CG_RankRunFrame( void );
 void CG_SetScoreSelection(void *menu);
-score_t *CG_GetSelectedScore( void );
-void CG_BuildSpectatorString( void );
+score_t *CG_GetSelectedScore(void);
+void CG_BuildSpectatorString(void);
 
 
 //
@@ -1276,23 +1276,23 @@
 void CG_Text_Paint(float x, float y, float scale, vec4_t color, const char *text, float adjust, int limit, int style);
 int CG_Text_Width(const char *text, float scale, int limit);
 int CG_Text_Height(const char *text, float scale, int limit);
-void CG_SelectPrevPlayer( void );
-void CG_SelectNextPlayer( void );
+void CG_SelectPrevPlayer(void);
+void CG_SelectNextPlayer(void);
 float CG_GetValue(int ownerDraw);
 qboolean CG_OwnerDrawVisible(int flags);
 void CG_RunMenuScript(char **args);
-void CG_ShowResponseHead( void );
+void CG_ShowResponseHead(void);
 void CG_SetPrintString(int type, const char *p);
-void CG_InitTeamChat( void );
+void CG_InitTeamChat(void);
 void CG_GetTeamColor(vec4_t *color);
-const char *CG_GetGameStatusText( void );
-const char *CG_GetKillerText( void );
-void CG_Draw3DModel(float x, float y, float w, float h, qhandle_t model, qhandle_t skin, vec3_t origin, vec3_t angles);
+const char *CG_GetGameStatusText(void);
+const char *CG_GetKillerText(void);
+void CG_Draw3DModel( float x, float y, float w, float h, qhandle_t model, qhandle_t skin, vec3_t origin, vec3_t angles );
 void CG_Text_PaintChar(float x, float y, float width, float height, float scale, float s, float t, float s2, float t2, qhandle_t hShader);
-void CG_CheckOrderPending( void );
-const char *CG_GameTypeString( void );
-qboolean CG_YourTeamHasFlag( void );
-qboolean CG_OtherTeamHasFlag( void );
+void CG_CheckOrderPending(void);
+const char *CG_GameTypeString(void);
+qboolean CG_YourTeamHasFlag(void);
+qboolean CG_OtherTeamHasFlag(void);
 qhandle_t CG_StatusHandle(int task);
 
 
@@ -1398,7 +1398,7 @@
 				   qhandle_t hShader );
 void CG_BubbleTrail( vec3_t start, vec3_t end, float spacing );
 void CG_SpawnEffect( vec3_t org );
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 void CG_KamikazeEffect( vec3_t org );
 void CG_ObeliskExplode( vec3_t org, int entityNum );
 void CG_ObeliskPain( vec3_t org );
@@ -1634,7 +1634,7 @@
   SYSTEM_PRINT,
   CHAT_PRINT,
   TEAMCHAT_PRINT
-} q3print_t;
+} q3print_t; // bk001201 - warning: useless keyword or type name in empty declaration
 
 
 int trap_CIN_PlayCinematic( const char *arg0, int xpos, int ypos, int width, int height, int bits);
@@ -1664,5 +1664,5 @@
 void	CG_ParticleExplosion (char *animStr, vec3_t origin, vec3_t vel, int duration, int sizeStart, int sizeEnd);
 extern qboolean		initparticles;
 int CG_NewParticleArea ( int num );
-
+qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelName, const char *skinName, const char *headModelName, const char *headSkinName, const char *teamName );
 
diff -Naur cgame.orig/cg_main.c cgame/cg_main.c
--- cgame.orig/cg_main.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_main.c	2009-12-06 16:30:58.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_main.c -- initialization and primary entry point for cgame
 #include "cg_local.h"
@@ -29,6 +9,8 @@
 displayContextDef_t cgDC;
 #endif
 
+#include "wolfcam_local.h"
+
 int forceModelModificationCount = -1;
 
 void CG_Init( int serverMessageNum, int serverCommandSequence, int clientNum );
@@ -62,6 +44,7 @@
 	case CG_LAST_ATTACKER:
 		return CG_LastAttacker();
 	case CG_KEY_EVENT:
+        //CG_Printf ("CG_KEY_EVENT: %d %d\n", arg0, arg1);
 		CG_KeyEvent(arg0, arg1);
 		return 0;
 	case CG_MOUSE_EVENT:
@@ -88,6 +71,10 @@
 weaponInfo_t		cg_weapons[MAX_WEAPONS];
 itemInfo_t			cg_items[MAX_ITEMS];
 
+clientInfo_t		EM_ModelInfo;
+int					EM_Loaded = 0;
+byte				EC_Colors[3][4];
+int					EC_Loaded = 0;
 
 vmCvar_t	cg_railTrailTime;
 vmCvar_t	cg_centertime;
@@ -142,6 +129,7 @@
 vmCvar_t	cg_thirdPerson;
 vmCvar_t	cg_thirdPersonRange;
 vmCvar_t	cg_thirdPersonAngle;
+vmCvar_t	cg_stereoSeparation;
 vmCvar_t	cg_lagometer;
 vmCvar_t	cg_drawAttacker;
 vmCvar_t	cg_synchronousClients;
@@ -196,6 +184,11 @@
 vmCvar_t	cg_obeliskRespawnDelay;
 #endif
 
+vmCvar_t cg_drawSpeed;
+
+vmCvar_t wolfcam_enemyModel;
+vmCvar_t wolfcam_enemyColors;  // "0 255 0   0 255 255  255 0 0"  head, torso, legs,   totoal of 9 numbers
+
 typedef struct {
 	vmCvar_t	*vmCvar;
 	char		*cvarName;
@@ -203,18 +196,19 @@
 	int			cvarFlags;
 } cvarTable_t;
 
-static cvarTable_t cvarTable[] = {
+static cvarTable_t cvarTable[] = { // bk001129
 	{ &cg_ignore, "cg_ignore", "0", 0 },	// used for debugging
 	{ &cg_autoswitch, "cg_autoswitch", "1", CVAR_ARCHIVE },
 	{ &cg_drawGun, "cg_drawGun", "1", CVAR_ARCHIVE },
 	{ &cg_zoomFov, "cg_zoomfov", "22.5", CVAR_ARCHIVE },
 	{ &cg_fov, "cg_fov", "90", CVAR_ARCHIVE },
 	{ &cg_viewsize, "cg_viewsize", "100", CVAR_ARCHIVE },
+	{ &cg_stereoSeparation, "cg_stereoSeparation", "0.4", CVAR_ARCHIVE  },
 	{ &cg_shadows, "cg_shadows", "1", CVAR_ARCHIVE  },
 	{ &cg_gibs, "cg_gibs", "1", CVAR_ARCHIVE  },
 	{ &cg_draw2D, "cg_draw2D", "1", CVAR_ARCHIVE  },
 	{ &cg_drawStatus, "cg_drawStatus", "1", CVAR_ARCHIVE  },
-	{ &cg_drawTimer, "cg_drawTimer", "0", CVAR_ARCHIVE  },
+	{ &cg_drawTimer, "cg_drawTimer", "1", CVAR_ARCHIVE  },
 	{ &cg_drawFPS, "cg_drawFPS", "0", CVAR_ARCHIVE  },
 	{ &cg_drawSnapshot, "cg_drawSnapshot", "0", CVAR_ARCHIVE  },
 	{ &cg_draw3dIcons, "cg_draw3dIcons", "1", CVAR_ARCHIVE  },
@@ -237,11 +231,11 @@
 	{ &cg_gun_y, "cg_gunY", "0", CVAR_CHEAT },
 	{ &cg_gun_z, "cg_gunZ", "0", CVAR_CHEAT },
 	{ &cg_centertime, "cg_centertime", "3", CVAR_CHEAT },
-	{ &cg_runpitch, "cg_runpitch", "0.002", CVAR_ARCHIVE},
-	{ &cg_runroll, "cg_runroll", "0.005", CVAR_ARCHIVE },
-	{ &cg_bobup , "cg_bobup", "0.005", CVAR_CHEAT },
-	{ &cg_bobpitch, "cg_bobpitch", "0.002", CVAR_ARCHIVE },
-	{ &cg_bobroll, "cg_bobroll", "0.002", CVAR_ARCHIVE },
+	{ &cg_runpitch, "cg_runpitch", "0", CVAR_ARCHIVE},  // 0.002
+	{ &cg_runroll, "cg_runroll", "0", CVAR_ARCHIVE },   // 0.005
+	{ &cg_bobup , "cg_bobup", "0", CVAR_CHEAT },        // 0.005
+	{ &cg_bobpitch, "cg_bobpitch", "0", CVAR_ARCHIVE }, // 0.002
+	{ &cg_bobroll, "cg_bobroll", "0", CVAR_ARCHIVE },   // 0.002
 	{ &cg_swingSpeed, "cg_swingSpeed", "0.3", CVAR_CHEAT },
 	{ &cg_animSpeed, "cg_animspeed", "1", CVAR_CHEAT },
 	{ &cg_debugAnim, "cg_debuganim", "0", CVAR_CHEAT },
@@ -265,7 +259,7 @@
 #ifdef MISSIONPACK
 	{ &cg_deferPlayers, "cg_deferPlayers", "0", CVAR_ARCHIVE },
 #else
-	{ &cg_deferPlayers, "cg_deferPlayers", "1", CVAR_ARCHIVE },
+	{ &cg_deferPlayers, "cg_deferPlayers", "0", CVAR_ARCHIVE },
 #endif
 	{ &cg_drawTeamOverlay, "cg_drawTeamOverlay", "0", CVAR_ARCHIVE },
 	{ &cg_teamOverlayUserinfo, "teamoverlay", "0", CVAR_ROM | CVAR_USERINFO },
@@ -312,8 +306,17 @@
 	{ &cg_oldRail, "cg_oldRail", "1", CVAR_ARCHIVE},
 	{ &cg_oldRocket, "cg_oldRocket", "1", CVAR_ARCHIVE},
 	{ &cg_oldPlasma, "cg_oldPlasma", "1", CVAR_ARCHIVE},
-	{ &cg_trueLightning, "cg_trueLightning", "0.0", CVAR_ARCHIVE}
+	{ &cg_trueLightning, "cg_trueLightning", "0.0", CVAR_ARCHIVE},
 //	{ &cg_pmove_fixed, "cg_pmove_fixed", "0", CVAR_USERINFO | CVAR_ARCHIVE }
+    { &cg_drawSpeed, "cg_drawSpeed", "1", CVAR_ARCHIVE },
+    { &wolfcam_execIntermission, "wolfcam_execIntermission", "", CVAR_ARCHIVE },
+    { &wolfcam_execShutdown, "wolfcam_execShutdown", "", CVAR_ARCHIVE },
+	{ &wolfcam_wh, "wolfcam_wh", "0", CVAR_ARCHIVE },
+	{ &wolfcam_fixedViewAngles, "wolfcam_fixedViewAngles", "0", CVAR_ARCHIVE },
+	{ &wolfcam_useOriginalInterpolation, "wolfcam_useOriginalInterpolation", "0", CVAR_ARCHIVE },
+	{ &wolfcam_drawBBox, "wolfcam_drawBBox", "0", CVAR_ARCHIVE },
+	{ &wolfcam_enemyModel, "wolfcam_enemyModel", "keel/bright", CVAR_ARCHIVE },
+	{ &wolfcam_enemyColors, "wolfcam_enemyColors", "0 255 0  0 255 0  0 255 0", CVAR_ARCHIVE },
 };
 
 static int  cvarTableSize = sizeof( cvarTable ) / sizeof( cvarTable[0] );
@@ -389,6 +392,8 @@
 		} else {
 			trap_Cvar_Set( "teamoverlay", "0" );
 		}
+		// FIXME E3 HACK
+		trap_Cvar_Set( "teamoverlay", "1" );
 	}
 
 	// if force model changed
@@ -434,6 +439,9 @@
 	trap_Error( text );
 }
 
+#ifndef CGAME_HARD_LINKED
+// this is only here so the functions in q_shared.c and bg_*.c can link (FIXME)
+
 void QDECL Com_Error( int level, const char *error, ... ) {
 	va_list		argptr;
 	char		text[1024];
@@ -456,6 +464,8 @@
 	CG_Printf ("%s", text);
 }
 
+#endif
+
 /*
 ================
 CG_Argv
@@ -550,7 +560,7 @@
 	cgs.media.count1Sound = trap_S_RegisterSound( "sound/feedback/one.wav", qtrue );
 	cgs.media.countFightSound = trap_S_RegisterSound( "sound/feedback/fight.wav", qtrue );
 	cgs.media.countPrepareSound = trap_S_RegisterSound( "sound/feedback/prepare.wav", qtrue );
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK  //FIXME check
 	cgs.media.countPrepareTeamSound = trap_S_RegisterSound( "sound/feedback/prepare_team.wav", qtrue );
 #endif
 
@@ -615,7 +625,7 @@
 	cgs.media.gibBounce2Sound = trap_S_RegisterSound( "sound/player/gibimp2.wav", qfalse );
 	cgs.media.gibBounce3Sound = trap_S_RegisterSound( "sound/player/gibimp3.wav", qfalse );
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	cgs.media.useInvulnerabilitySound = trap_S_RegisterSound( "sound/items/invul_activate.wav", qfalse );
 	cgs.media.invulnerabilityImpactSound1 = trap_S_RegisterSound( "sound/items/invul_impact_01.wav", qfalse );
 	cgs.media.invulnerabilityImpactSound2 = trap_S_RegisterSound( "sound/items/invul_impact_02.wav", qfalse );
@@ -626,7 +636,9 @@
 	cgs.media.obeliskHitSound3 = trap_S_RegisterSound( "sound/items/obelisk_hit_03.wav", qfalse );
 	cgs.media.obeliskRespawnSound = trap_S_RegisterSound( "sound/items/obelisk_respawn.wav", qfalse );
 
-	cgs.media.ammoregenSound = trap_S_RegisterSound("sound/items/cl_ammoregen.wav", qfalse);
+	//cgs.media.ammoregenSound = trap_S_RegisterSound("sound/items/cl_ammoregen.wav", qfalse);
+	//FIXME armorregen not ammoregen
+	cgs.media.ammoregenSound = trap_S_RegisterSound("sound/items/cl_armorregen.wav", qfalse);
 	cgs.media.doublerSound = trap_S_RegisterSound("sound/items/cl_doubler.wav", qfalse);
 	cgs.media.guardSound = trap_S_RegisterSound("sound/items/cl_guard.wav", qfalse);
 	cgs.media.scoutSound = trap_S_RegisterSound("sound/items/cl_scout.wav", qfalse);
@@ -653,7 +665,7 @@
 	cgs.media.humiliationSound = trap_S_RegisterSound( "sound/feedback/humiliation.wav", qtrue );
 	cgs.media.assistSound = trap_S_RegisterSound( "sound/feedback/assist.wav", qtrue );
 	cgs.media.defendSound = trap_S_RegisterSound( "sound/feedback/defense.wav", qtrue );
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK  //FIXME think so, check demo
 	cgs.media.firstImpressiveSound = trap_S_RegisterSound( "sound/feedback/first_impressive.wav", qtrue );
 	cgs.media.firstExcellentSound = trap_S_RegisterSound( "sound/feedback/first_excellent.wav", qtrue );
 	cgs.media.firstHumiliationSound = trap_S_RegisterSound( "sound/feedback/first_gauntlet.wav", qtrue );
@@ -696,10 +708,12 @@
 
 		Com_sprintf (name, sizeof(name), "sound/player/footsteps/clank%i.wav", i+1);
 		cgs.media.footsteps[FOOTSTEP_METAL][i] = trap_S_RegisterSound (name, qfalse);
+		Com_sprintf (name, sizeof(name), "sound/player/footsteps/wood%i.wav", i+1);
+		cgs.media.footsteps[FOOTSTEP_WOOD][i] = trap_S_RegisterSound (name, qfalse);
 	}
 
 	// only register the items that the server says we need
-	Q_strncpyz(items, CG_ConfigString(CS_ITEMS), sizeof(items));
+	strcpy( items, CG_ConfigString( CS_ITEMS ) );
 
 	for ( i = 1 ; i < bg_numItems ; i++ ) {
 //		if ( items[ i ] == '1' || cg_buildScript.integer ) {
@@ -728,7 +742,7 @@
 	cgs.media.sfx_railg = trap_S_RegisterSound ("sound/weapons/railgun/railgf1a.wav", qfalse);
 	cgs.media.sfx_rockexp = trap_S_RegisterSound ("sound/weapons/rocket/rocklx1a.wav", qfalse);
 	cgs.media.sfx_plasmaexp = trap_S_RegisterSound ("sound/weapons/plasma/plasmx1a.wav", qfalse);
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	cgs.media.sfx_proxexp = trap_S_RegisterSound( "sound/weapons/proxmine/wstbexpl.wav" , qfalse);
 	cgs.media.sfx_nghit = trap_S_RegisterSound( "sound/weapons/nailgun/wnalimpd.wav" , qfalse);
 	cgs.media.sfx_nghitflesh = trap_S_RegisterSound( "sound/weapons/nailgun/wnalimpl.wav" , qfalse);
@@ -847,7 +861,7 @@
 	cgs.media.smokePuffShader = trap_R_RegisterShader( "smokePuff" );
 	cgs.media.smokePuffRageProShader = trap_R_RegisterShader( "smokePuffRagePro" );
 	cgs.media.shotgunSmokePuffShader = trap_R_RegisterShader( "shotgunSmokePuff" );
-#ifdef MISSIONPACK
+#if  1 //def MPACK
 	cgs.media.nailPuffShader = trap_R_RegisterShader( "nailtrail" );
 	cgs.media.blueProxMine = trap_R_RegisterModel( "models/weaphits/proxmineb.md3" );
 #endif
@@ -901,7 +915,7 @@
 		cgs.media.blueFlagShader[0] = trap_R_RegisterShaderNoMip( "icons/iconf_blu1" );
 		cgs.media.blueFlagShader[1] = trap_R_RegisterShaderNoMip( "icons/iconf_blu2" );
 		cgs.media.blueFlagShader[2] = trap_R_RegisterShaderNoMip( "icons/iconf_blu3" );
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK  //FIXME check demo
 		cgs.media.flagPoleModel = trap_R_RegisterModel( "models/flag2/flagpole.md3" );
 		cgs.media.flagFlapModel = trap_R_RegisterModel( "models/flag2/flagflap3.md3" );
 
@@ -977,13 +991,13 @@
 	cgs.media.bulletFlashModel = trap_R_RegisterModel("models/weaphits/bullet.md3");
 	cgs.media.ringFlashModel = trap_R_RegisterModel("models/weaphits/ring02.md3");
 	cgs.media.dishFlashModel = trap_R_RegisterModel("models/weaphits/boom01.md3");
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	cgs.media.teleportEffectModel = trap_R_RegisterModel( "models/powerups/pop.md3" );
 #else
 	cgs.media.teleportEffectModel = trap_R_RegisterModel( "models/misc/telep.md3" );
 	cgs.media.teleportEffectShader = trap_R_RegisterShader( "teleportEffect" );
 #endif
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	cgs.media.kamikazeEffectModel = trap_R_RegisterModel( "models/weaphits/kamboom2.md3" );
 	cgs.media.kamikazeShockWave = trap_R_RegisterModel( "models/weaphits/kamwave.md3" );
 	cgs.media.kamikazeHeadModel = trap_R_RegisterModel( "models/powerups/kamikazi.md3" );
@@ -1012,7 +1026,7 @@
 	memset( cg_weapons, 0, sizeof( cg_weapons ) );
 
 	// only register the items that the server says we need
-	Q_strncpyz(items, CG_ConfigString(CS_ITEMS), sizeof(items));
+	strcpy( items, CG_ConfigString( CS_ITEMS) );
 
 	for ( i = 1 ; i < bg_numItems ; i++ ) {
 		if ( items[ i ] == '1' || cg_buildScript.integer ) {
@@ -1175,6 +1189,10 @@
 	char	*s;
 	char	parm1[MAX_QPATH], parm2[MAX_QPATH];
 
+	//FIXME
+	//CG_Printf("FIXME CG_StartMusic()\n");
+	//return;
+
 	// start the background music
 	s = (char *)CG_ConfigString( CS_MUSIC );
 	Q_strncpyz( parm1, COM_Parse( &s ), sizeof( parm1 ) );
@@ -1355,7 +1373,7 @@
 			continue;
 		}
 	}
-	return qfalse;
+	return qfalse; // bk001204 - why not?
 }
 
 void CG_ParseMenu(const char *menuFile) {
@@ -1446,7 +1464,7 @@
 		trap_Error( va( S_COLOR_YELLOW "menu file not found: %s, using default\n", menuFile ) );
 		len = trap_FS_FOpenFile( "ui/hud.txt", &f, FS_READ );
 		if (!f) {
-			trap_Error( va( S_COLOR_RED "default menu file not found: ui/hud.txt, unable to continue!\n") );
+			trap_Error( va( S_COLOR_RED "default menu file not found: ui/hud.txt, unable to continue!\n", menuFile ) );
 		}
 	}
 
@@ -1688,7 +1706,7 @@
 }
 #endif
 
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK // bk001204 - only needed there
 static float CG_Cvar_Get(const char *cvar) {
 	char buff[128];
 	memset(buff, 0, sizeof(buff));
@@ -1747,7 +1765,7 @@
 
 =================
 */
-void CG_LoadHudMenu( void ) {
+void CG_LoadHudMenu() {
 	char buff[1024];
 	const char *hudSet;
 
@@ -1814,7 +1832,7 @@
 	CG_LoadMenus(hudSet);
 }
 
-void CG_AssetCache( void ) {
+void CG_AssetCache() {
 	//if (Assets.textFont == NULL) {
 	//  trap_R_RegisterFont("fonts/arial.ttf", 72, &Assets.textFont);
 	//}
@@ -1890,7 +1908,10 @@
 	// check version
 	s = CG_ConfigString( CS_GAME_VERSION );
 	if ( strcmp( s, GAME_VERSION ) ) {
-		CG_Error( "Client/Server game mismatch: %s/%s", GAME_VERSION, s );
+		//CG_Error( "Client/Server game mismatch: %s/%s", GAME_VERSION, s );
+        CG_Printf ("Client/Server game mismatch: %s/%s\n", GAME_VERSION, s);
+        //trap_SendConsoleCommand ("quit");
+        //return;
 	}
 
 	s = CG_ConfigString( CS_LEVEL_START_TIME );
@@ -1949,6 +1970,31 @@
 	CG_ShaderStateChanged();
 
 	trap_S_ClearLoopingSounds( qtrue );
+
+    if (!wc_logfile) {
+        char *fname = "shotdata.log";
+        int ret;
+
+#if 0
+        // clear it first
+        ret = trap_FS_FOpenFile (fname, &wc_logfile, FS_WRITE);
+        if (!wc_logfile  ||  ret < 0) {
+            CG_Printf ("Error clearing %s\n", fname);
+        } else {
+            trap_FS_FCloseFile (wc_logfile);
+            ret = trap_FS_FOpenFile (fname, &wc_logfile, FS_APPEND_SYNC);
+            if (!wc_logfile  ||  ret < 0)
+                CG_Printf ("Error opening shotdata.log\n");
+        }
+#endif
+        ret = trap_FS_FOpenFile (fname, &wc_logfile, FS_APPEND_SYNC);
+        if (!wc_logfile  ||  ret < 0)
+            CG_Printf ("Error opening shotdata.log\n");
+    }
+    //FIXME wolfcam
+    //CG_EventHandling(CGAME_EVENT_DEMO);
+    //trap_Key_SetCatcher(trap_Key_GetCatcher() | KEYCATCH_CGAME);
+    //trap_Key_SetCatcher(KEYCATCH_CGAME);
 }
 
 /*
@@ -1961,6 +2007,8 @@
 void CG_Shutdown( void ) {
 	// some mods may need to do cleanup work here,
 	// like closing files or archiving session data
+    //Wolfcam_Weapon_Statsall_f ();
+    trap_SendConsoleCommand ("vstr wolfcam_execShutdown");
 }
 
 
@@ -1975,11 +2023,37 @@
 */
 #ifndef MISSIONPACK
 void CG_EventHandling(int type) {
+    cgs.eventHandling = type;
+
+    CG_Printf ("test\n");
+#if 0
+    if (type == CGAME_EVENT_NONE) {
+        if (cg.demoPlayback) {
+            type = CGAME_EVENT_DEMO;
+            //CG_ScoresUp_f ();
+        }
+    }
+#endif
+
 }
 
 
 
 void CG_KeyEvent(int key, qboolean down) {
+    switch (cgs.eventHandling) {
+    case CGAME_EVENT_DEMO:
+        Wolfcam_DemoClick (key, down);
+        return;
+    default:
+        break;
+    }
+
+    if ( cg.predictedPlayerState.pm_type == PM_NORMAL || (cg.predictedPlayerState.pm_type == PM_SPECTATOR && cg.showScores == qfalse)) {
+        CG_EventHandling(CGAME_EVENT_NONE);
+        trap_Key_SetCatcher(0);
+        return;
+    }
+
 }
 
 void CG_MouseEvent(int x, int y) {
diff -Naur cgame.orig/cg_marks.c cgame/cg_marks.c
--- cgame.orig/cg_marks.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_marks.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_marks.c -- wall marks
 
diff -Naur cgame.orig/cg_newdraw.c cgame/cg_newdraw.c
--- cgame.orig/cg_newdraw.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_newdraw.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,32 +1,13 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
 
-#ifndef MISSIONPACK
+#ifndef MISSIONPACK // bk001204
 #error This file not be used for classic Q3A.
 #endif
 
 #include "cg_local.h"
 #include "../ui/ui_shared.h"
 
+#include "wolfcam_local.h"
+
 extern displayContextDef_t cgDC;
 
 
@@ -40,7 +21,7 @@
 //static char teamChat1[256];
 //static char teamChat2[256];
 
-void CG_InitTeamChat(void) {
+void CG_InitTeamChat() {
   memset(teamChat1, 0, sizeof(teamChat1));
   memset(teamChat2, 0, sizeof(teamChat2));
   memset(systemChat, 0, sizeof(systemChat));
@@ -55,7 +36,7 @@
   }
 }
 
-void CG_CheckOrderPending(void) {
+void CG_CheckOrderPending() {
 	if (cgs.gametype < GT_CTF) {
 		return;
 	}
@@ -119,7 +100,7 @@
 	}
 }
 
-static void CG_SetSelectedPlayerName( void ) {
+static void CG_SetSelectedPlayerName() {
   if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
 		clientInfo_t *ci = cgs.clientinfo + sortedTeamPlayers[cg_currentSelectedPlayer.integer];
 	  if (ci) {
@@ -131,14 +112,14 @@
 		trap_Cvar_Set("cg_selectedPlayerName", "Everyone");
 	}
 }
-int CG_GetSelectedPlayer( void ) {
+int CG_GetSelectedPlayer() {
 	if (cg_currentSelectedPlayer.integer < 0 || cg_currentSelectedPlayer.integer >= numSortedTeamPlayers) {
 		cg_currentSelectedPlayer.integer = 0;
 	}
 	return cg_currentSelectedPlayer.integer;
 }
 
-void CG_SelectNextPlayer( void ) {
+void CG_SelectNextPlayer() {
 	CG_CheckOrderPending();
 	if (cg_currentSelectedPlayer.integer >= 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
 		cg_currentSelectedPlayer.integer++;
@@ -148,7 +129,7 @@
 	CG_SetSelectedPlayerName();
 }
 
-void CG_SelectPrevPlayer( void ) {
+void CG_SelectPrevPlayer() {
 	CG_CheckOrderPending();
 	if (cg_currentSelectedPlayer.integer > 0 && cg_currentSelectedPlayer.integer < numSortedTeamPlayers) {
 		cg_currentSelectedPlayer.integer--;
@@ -172,7 +153,7 @@
 	cent = &cg_entities[cg.snap->ps.clientNum];
 	ps = &cg.snap->ps;
 
-	if ( draw2D || ( !cg_draw3dIcons.integer && cg_drawIcons.integer) ) {
+	if ( draw2D || ( !cg_draw3dIcons.integer && cg_drawIcons.integer) ) { // bk001206 - parentheses
 		CG_DrawPic( rect->x, rect->y + rect->h/2 + 1, rect->w, rect->h, cgs.media.armorIcon );
   } else if (cg_draw3dIcons.integer) {
 	  VectorClear( angles );
@@ -209,9 +190,10 @@
 	}
 }
 
-#ifndef MISSIONPACK
+#ifndef MISSIONPACK // bk001206 
 static float healthColors[4][4] = { 
 //		{ 0.2, 1.0, 0.2, 1.0 } , { 1.0, 0.2, 0.2, 1.0 }, {0.5, 0.5, 0.5, 1} };
+  // bk0101016 - float const
   { 1.0f, 0.69f, 0.0f, 1.0f } ,		// normal
   { 1.0f, 0.2f, 0.2f, 1.0f },		// low health
   { 0.5f, 0.5f, 0.5f, 1.0f},		// weapon firing
@@ -227,7 +209,7 @@
 	cent = &cg_entities[cg.snap->ps.clientNum];
 	ps = &cg.snap->ps;
 
-	if ( draw2D || (!cg_draw3dIcons.integer && cg_drawIcons.integer) ) {
+	if ( draw2D || (!cg_draw3dIcons.integer && cg_drawIcons.integer) ) { // bk001206 - parentheses
 	  qhandle_t	icon;
     icon = cg_weapons[ cg.predictedPlayerState.weapon ].ammoIcon;
 		if ( icon ) {
@@ -951,7 +933,7 @@
 	return -1;
 }
 
-qboolean CG_OtherTeamHasFlag(void) {
+qboolean CG_OtherTeamHasFlag() {
 	if (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF) {
 		int team = cg.snap->ps.persistant[PERS_TEAM];
 		if (cgs.gametype == GT_1FCTF) {
@@ -975,7 +957,7 @@
 	return qfalse;
 }
 
-qboolean CG_YourTeamHasFlag(void) {
+qboolean CG_YourTeamHasFlag() {
 	if (cgs.gametype == GT_CTF || cgs.gametype == GT_1FCTF) {
 		int team = cg.snap->ps.persistant[PERS_TEAM];
 		if (cgs.gametype == GT_1FCTF) {
@@ -1130,7 +1112,7 @@
   CG_Text_Paint(rect->x, rect->y + rect->h, scale, color, teamChat2, 0, 0, 0);
 }
 
-const char *CG_GetKillerText(void) {
+const char *CG_GetKillerText() {
 	const char *s = "";
 	if ( cg.killerName[0] ) {
 		s = va("Fragged by %s", cg.killerName );
@@ -1166,7 +1148,7 @@
 	}
 }
 
-const char *CG_GetGameStatusText(void) {
+const char *CG_GetGameStatusText() {
 	const char *s = "";
 	if ( cgs.gametype < GT_TEAM) {
 		if (cg.snap->ps.persistant[PERS_TEAM] != TEAM_SPECTATOR ) {
@@ -1188,7 +1170,7 @@
 	CG_Text_Paint(rect->x, rect->y + rect->h, scale, color, CG_GetGameStatusText(), 0, 0, textStyle);
 }
 
-const char *CG_GameTypeString(void) {
+const char *CG_GameTypeString() {
 	if ( cgs.gametype == GT_FFA ) {
 		return "Free For All";
 	} else if ( cgs.gametype == GT_TEAM ) {
@@ -1213,6 +1195,8 @@
 	vec4_t newColor;
 	glyphInfo_t *glyph;
   if (text) {
+// TTimo: FIXME
+//    const unsigned char *s = text; // bk001206 - unsigned
     const char *s = text;
 		float max = *maxX;
 		float useScale;
@@ -1701,6 +1685,16 @@
 void CG_MouseEvent(int x, int y) {
 	int n;
 
+    switch (cgs.eventHandling) {
+    case CGAME_EVENT_DEMO:
+        //FIXME wolfcam
+        return;
+    default:
+        CG_EventHandling(CGAME_EVENT_NONE);
+        trap_Key_SetCatcher(trap_Key_GetCatcher() & ~KEYCATCH_CGAME );
+        break;
+    }
+
 	if ( (cg.predictedPlayerState.pm_type == PM_NORMAL || cg.predictedPlayerState.pm_type == PM_SPECTATOR) && cg.showScores == qfalse) {
     trap_Key_SetCatcher(0);
 		return;
@@ -1740,7 +1734,7 @@
 ==================
 
 */
-void CG_HideTeamMenu( void ) {
+void CG_HideTeamMenu() {
   Menus_CloseByName("teamMenu");
   Menus_CloseByName("getMenu");
 }
@@ -1751,7 +1745,7 @@
 ==================
 
 */
-void CG_ShowTeamMenu( void ) {
+void CG_ShowTeamMenu() {
   Menus_OpenByName("teamMenu");
 }
 
@@ -1768,8 +1762,13 @@
 
 */
 void CG_EventHandling(int type) {
+    CG_Printf ("^3CG_EventHandling: type==%d\n", type);
+
 	cgs.eventHandling = type;
   if (type == CGAME_EVENT_NONE) {
+      if (cg.demoPlayback) {
+          //type = CGAME_EVENT_DEMO;
+      }
     CG_HideTeamMenu();
   } else if (type == CGAME_EVENT_TEAMMENU) {
     //CG_ShowTeamMenu();
@@ -1782,13 +1781,25 @@
 
 void CG_KeyEvent(int key, qboolean down) {
 
-	if (!down) {
-		return;
-	}
+	//if (!down) {
+	//	return;
+	//}
+
+    CG_Printf ("CG_KeyEvent: %d %d %d\n", key, down, cgs.eventHandling);
+
+    switch (cgs.eventHandling) {
+    case CGAME_EVENT_DEMO:
+        Wolfcam_DemoClick (key, down);
+        return;
+    default:
+        //CG_EventHandling(CGAME_EVENT_NONE);
+        //trap_Key_SetCatcher(trap_Key_GetCatcher() & ~KEYCATCH_CGAME );
+        break;
+    }
 
 	if ( cg.predictedPlayerState.pm_type == PM_NORMAL || (cg.predictedPlayerState.pm_type == PM_SPECTATOR && cg.showScores == qfalse)) {
 		CG_EventHandling(CGAME_EVENT_NONE);
-    trap_Key_SetCatcher(0);
+        trap_Key_SetCatcher(0);
 		return;
 	}
 
@@ -1821,7 +1832,7 @@
   return -1;
 }
 
-void CG_ShowResponseHead(void) {
+void CG_ShowResponseHead() {
   Menus_OpenByName("voiceMenu");
 	trap_Cvar_Set("cl_conXOffset", "72");
 	cg.voiceTime = cg.time;
diff -Naur cgame.orig/cg_particles.c cgame/cg_particles.c
--- cgame.orig/cg_particles.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_particles.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,24 +1,3 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
 // Rafael particles
 // cg_particles.c  
 
@@ -1252,7 +1231,7 @@
 
 	// find the animation string
 	for (anim=0; shaderAnimNames[anim]; anim++) {
-		if (!Q_stricmp( animStr, shaderAnimNames[anim] ))
+		if (!stricmp( animStr, shaderAnimNames[anim] ))
 			break;
 	}
 	if (!shaderAnimNames[anim]) {
diff -Naur cgame.orig/cg_players.c cgame/cg_players.c
--- cgame.orig/cg_players.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_players.c	2009-12-05 18:06:22.000000000 -0500
@@ -1,27 +1,8 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_players.c -- handle the media and animation for player entities
 #include "cg_local.h"
+#include "wolfcam_local.h"
 
 char	*cg_customSoundNames[MAX_CUSTOM_SOUNDS] = {
 	"*death1.wav",
@@ -107,7 +88,6 @@
 	}
 	if ( len >= sizeof( text ) - 1 ) {
 		CG_Printf( "File %s too long\n", filename );
-		trap_FS_FCloseFile( f );
 		return qfalse;
 	}
 	trap_FS_Read( text, len, f );
@@ -298,7 +278,7 @@
 static qboolean	CG_FileExists(const char *filename) {
 	int len;
 
-	len = trap_FS_FOpenFile( filename, NULL, FS_READ );
+	len = trap_FS_FOpenFile( filename, 0, FS_READ );
 	if (len>0) {
 		return qtrue;
 	}
@@ -343,7 +323,7 @@
 			if ( CG_FileExists( filename ) ) {
 				return qtrue;
 			}
-			if ( cgs.gametype >= GT_TEAM ) {
+			if ( cgs.gametype >= GT_TEAM   &&   !*wolfcam_enemyModel.string) {
 				if ( i == 0 && teamName && *teamName ) {
 					//								"models/players/characters/james/stroggs/lower_red.skin"
 					Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s.%s", charactersFolder, modelName, teamName, base, team, ext );
@@ -423,7 +403,7 @@
 			if ( CG_FileExists( filename ) ) {
 				return qtrue;
 			}
-			if ( cgs.gametype >= GT_TEAM ) {
+			if ( cgs.gametype >= GT_TEAM   &&   !*wolfcam_enemyModel.string) {
 				if ( i == 0 &&  teamName && *teamName ) {
 					Com_sprintf( filename, length, "models/players/%s%s/%s%s_%s.%s", headsFolder, headModelName, teamName, base, team, ext );
 				}
@@ -463,6 +443,13 @@
 */
 static qboolean	CG_RegisterClientSkin( clientInfo_t *ci, const char *teamName, const char *modelName, const char *skinName, const char *headModelName, const char *headSkinName ) {
 	char filename[MAX_QPATH];
+	int vlight;
+
+#if 1
+	vlight = SC_Cvar_Get_Int("r_vertexlight");
+	if (vlight)
+		trap_Cvar_Set("r_vertexlight", "0");
+#endif
 
 	/*
 	Com_sprintf( filename, sizeof( filename ), "models/players/%s/%slower_%s.skin", modelName, teamName, skinName );
@@ -507,6 +494,8 @@
 		Com_Printf( "Head skin load failure: %s\n", filename );
 	}
 
+	trap_Cvar_Set("r_vertexlight", va("%d", vlight));
+
 	// if any skins failed to load
 	if ( !ci->legsSkin || !ci->torsoSkin || !ci->headSkin ) {
 		return qfalse;
@@ -519,7 +508,7 @@
 CG_RegisterClientModelname
 ==========================
 */
-static qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelName, const char *skinName, const char *headModelName, const char *headSkinName, const char *teamName ) {
+qboolean CG_RegisterClientModelname( clientInfo_t *ci, const char *modelName, const char *skinName, const char *headModelName, const char *headSkinName, const char *teamName ) {
 	char	filename[MAX_QPATH*2];
 	const char		*headName;
 	char newTeamName[MAX_QPATH*2];
@@ -571,6 +560,7 @@
 
 	// if any skins failed to load, return failure
 	if ( !CG_RegisterClientSkin( ci, teamName, modelName, skinName, headName, headSkinName ) ) {
+		//Com_Printf("wtf\n");
 		if ( teamName && *teamName) {
 			Com_Printf( "Failed to load skin file: %s : %s : %s, %s : %s\n", teamName, modelName, skinName, headName, headSkinName );
 			if( ci->team == TEAM_BLUE ) {
@@ -607,22 +597,42 @@
 	}
 
 	if ( !ci->modelIcon ) {
-		return qfalse;
+		//Com_Printf("!ci->modelIcon  %s\n", filename);
+		// who cares
+		//return qfalse;
 	}
 
 	return qtrue;
 }
 
+static void CG_Q3ColorFromString( const char *v, vec3_t color ) {
+	VectorClear( color );
+
+	color[0] = g_color_table_q3[ColorIndex(v[0])][0];
+	color[1] = g_color_table_q3[ColorIndex(v[0])][1];
+	color[2] = g_color_table_q3[ColorIndex(v[0])][2];
+
+	return;
+}
+
+#if 0
 /*
 ====================
 CG_ColorFromString
 ====================
 */
 static void CG_ColorFromString( const char *v, vec3_t color ) {
-	int val;
+	//int val;
 
 	VectorClear( color );
 
+	color[0] = g_color_table[ColorIndex(v[0])][0];
+	color[1] = g_color_table[ColorIndex(v[0])][1];
+	color[2] = g_color_table[ColorIndex(v[0])][2];
+
+	return;
+
+#if 0
 	val = atoi( v );
 
 	if ( val < 1 || val > 7 ) {
@@ -639,7 +649,9 @@
 	if ( val & 4 ) {
 		color[0] = 1.0f;
 	}
+#endif
 }
+#endif
 
 /*
 ===================
@@ -649,10 +661,11 @@
 This will usually be deferred to a safe time
 ===================
 */
-static void CG_LoadClientInfo( int clientNum, clientInfo_t *ci ) {
+static void CG_LoadClientInfo( clientInfo_t *ci ) {
 	const char	*dir, *fallback;
 	int			i, modelloaded;
 	const char	*s;
+	int			clientNum;
 	char		teamname[MAX_QPATH];
 
 	teamname[0] = 0;
@@ -670,6 +683,7 @@
 #endif
 	modelloaded = qtrue;
 	if ( !CG_RegisterClientModelname( ci, ci->modelName, ci->skinName, ci->headModelName, ci->headSkinName, teamname ) ) {
+		CG_Printf("couldn't load %s %s %s %s %s\n", ci->modelName, ci->skinName, ci->headModelName, ci->headSkinName, teamname);
 		if ( cg_buildScript.integer ) {
 			CG_Error( "CG_RegisterClientModelname( %s, %s, %s, %s %s ) failed", ci->modelName, ci->skinName, ci->headModelName, ci->headSkinName, teamname );
 		}
@@ -683,11 +697,13 @@
 				Q_strncpyz(teamname, DEFAULT_REDTEAM_NAME, sizeof(teamname) );
 			}
 			if ( !CG_RegisterClientModelname( ci, DEFAULT_TEAM_MODEL, ci->skinName, DEFAULT_TEAM_HEAD, ci->skinName, teamname ) ) {
-				CG_Error( "DEFAULT_TEAM_MODEL / skin (%s/%s) failed to register", DEFAULT_TEAM_MODEL, ci->skinName );
+				//CG_Error( "DEFAULT_TEAM_MODEL / skin (%s/%s) failed to register", DEFAULT_TEAM_MODEL, ci->skinName );
+				CG_Printf( "DEFAULT_TEAM_MODEL / skin (%s/%s) failed to register\n", DEFAULT_TEAM_MODEL, ci->skinName );
 			}
 		} else {
 			if ( !CG_RegisterClientModelname( ci, DEFAULT_MODEL, "default", DEFAULT_MODEL, "default", teamname ) ) {
-				CG_Error( "DEFAULT_MODEL (%s) failed to register", DEFAULT_MODEL );
+				//CG_Error( "DEFAULT_MODEL (%s) failed to register", DEFAULT_MODEL );
+				CG_Printf( "DEFAULT_MODEL (%s) failed to register\n", DEFAULT_MODEL );
 			}
 		}
 		modelloaded = qfalse;
@@ -725,6 +741,7 @@
 
 	// reset any existing players and bodies, because they might be in bad
 	// frames for this new model
+	clientNum = ci - cgs.clientinfo;
 	for ( i = 0 ; i < MAX_GENTITIES ; i++ ) {
 		if ( cg_entities[i].currentState.clientNum == clientNum
 			&& cg_entities[i].currentState.eType == ET_PLAYER ) {
@@ -803,7 +820,7 @@
 client's info to use until we have some spare time.
 ======================
 */
-static void CG_SetDeferredClientInfo( int clientNum, clientInfo_t *ci ) {
+static void CG_SetDeferredClientInfo( clientInfo_t *ci ) {
 	int		i;
 	clientInfo_t	*match;
 
@@ -822,7 +839,7 @@
 			continue;
 		}
 		// just load the real info cause it uses the same models and skins
-		CG_LoadClientInfo( clientNum, ci );
+		CG_LoadClientInfo( ci );
 		return;
 	}
 
@@ -845,7 +862,7 @@
 		// an improper team skin.  This will cause a hitch for the first
 		// player, when the second enters.  Combat shouldn't be going on
 		// yet, so it shouldn't matter
-		CG_LoadClientInfo( clientNum, ci );
+		CG_LoadClientInfo( ci );
 		return;
 	}
 
@@ -864,7 +881,7 @@
 	// we should never get here...
 	CG_Printf( "CG_SetDeferredClientInfo: no valid clients!\n" );
 
-	CG_LoadClientInfo( clientNum, ci );
+	CG_LoadClientInfo( ci );
 }
 
 
@@ -875,16 +892,48 @@
 */
 void CG_NewClientInfo( int clientNum ) {
 	clientInfo_t *ci;
+	clientInfo_t *ciOrig;
 	clientInfo_t newInfo;
 	const char	*configstring;
 	const char	*v;
 	char		*slash;
 
 	ci = &cgs.clientinfo[clientNum];
+	ciOrig = &cgs.clientinfoOrig[clientNum];
 
 	configstring = CG_ConfigString( clientNum + CS_PLAYERS );
 	if ( !configstring[0] ) {
+        if (wnumOldClients >= MAX_CLIENTS) {
+            CG_Printf ("CG_NewClientInfo: wnumOldClients >= MAX_CLIENTS\n");
+        } else {
+            woldclient_t *wold = &woldclients[wnumOldClients];
+            wclient_t *wc = &wclients[clientNum];
+
+            wold->valid = qtrue;
+            wold->clientNum = clientNum;
+            memcpy (&(wold->clientinfo), ci, sizeof (*ci));
+            //            wold->kills = wclients[clientNum].kills;
+            wold->kills = wc->kills;
+            wold->deaths = wclients[clientNum].deaths;
+            wold->suicides = wclients[clientNum].suicides;
+            wold->warp = wc->warp;
+            wold->nowarp = wclients[clientNum].nowarp;
+            wold->warpaccum = wc->warpaccum;
+			wold->validCount = wc->validCount;
+			wold->invalidCount = wc->invalidCount;
+			wold->serverPingAccum = wc->serverPingAccum;
+			wold->serverPingSamples = wc->serverPingSamples;
+			wold->snapshotPingAccum = wc->snapshotPingAccum;
+			wold->snapshotPingSamples = wc->snapshotPingSamples;
+			wold->noCommandCount = wc->noCommandCount;
+
+            memcpy (&(wold->wstats), &(wclients[clientNum].wstats), sizeof(wweaponStats_t) * WP_NUM_WEAPONS);
+            wnumOldClients++;
+        }
+
+        memset (&wclients[clientNum], 0, sizeof(wclient_t));        
 		memset( ci, 0, sizeof( *ci ) );
+		memset(ciOrig, 0, sizeof(*ciOrig));
 		return;		// player just left
 	}
 
@@ -898,10 +947,10 @@
 
 	// colors
 	v = Info_ValueForKey( configstring, "c1" );
-	CG_ColorFromString( v, newInfo.color1 );
+	CG_Q3ColorFromString( v, newInfo.color1 );
 
 	v = Info_ValueForKey( configstring, "c2" );
-	CG_ColorFromString( v, newInfo.color2 );
+	CG_Q3ColorFromString( v, newInfo.color2 );
 
 	// bot skill
 	v = Info_ValueForKey( configstring, "skill" );
@@ -939,7 +988,7 @@
 
 	// model
 	v = Info_ValueForKey( configstring, "model" );
-	if ( cg_forceModel.integer ) {
+	if ( cg_forceModel.integer ) {  // use wolfcam_enemyModel
 		// forcemodel makes everyone use a single model
 		// to prevent load hitches
 		char modelStr[MAX_QPATH];
@@ -983,7 +1032,7 @@
 
 	// head model
 	v = Info_ValueForKey( configstring, "hmodel" );
-	if ( cg_forceModel.integer ) {
+	if ( cg_forceModel.integer ) {  // use wolfcam_enemyModel
 		// forcemodel makes everyone use a single model
 		// to prevent load hitches
 		char modelStr[MAX_QPATH];
@@ -1035,20 +1084,21 @@
 		// if we are defering loads, just have it pick the first valid
 		if ( forceDefer || (cg_deferPlayers.integer && !cg_buildScript.integer && !cg.loading ) ) {
 			// keep whatever they had if it won't violate team skins
-			CG_SetDeferredClientInfo( clientNum, &newInfo );
+			CG_SetDeferredClientInfo( &newInfo );
 			// if we are low on memory, leave them with this model
 			if ( forceDefer ) {
 				CG_Printf( "Memory is low.  Using deferred model.\n" );
 				newInfo.deferred = qfalse;
 			}
 		} else {
-			CG_LoadClientInfo( clientNum, &newInfo );
+			CG_LoadClientInfo( &newInfo );
 		}
 	}
 
 	// replace whatever was there with the new one
 	newInfo.infoValid = qtrue;
 	*ci = newInfo;
+	*ciOrig = newInfo;
 }
 
 
@@ -1075,7 +1125,7 @@
 				ci->deferred = qfalse;
 				continue;
 			}
-			CG_LoadClientInfo( i, ci );
+			CG_LoadClientInfo( ci );
 //			break;
 		}
 	}
@@ -1752,7 +1802,7 @@
 }
 
 
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK // bk001204
 /*
 ===============
 CG_PlayerTokens
@@ -1969,6 +2019,8 @@
 	}
 
 	team = cgs.clientinfo[ cent->currentState.clientNum ].team;
+
+#if 0
 	if ( !(cent->currentState.eFlags & EF_DEAD) && 
 		cg.snap->ps.persistant[PERS_TEAM] == team &&
 		cgs.gametype >= GT_TEAM) {
@@ -1977,6 +2029,23 @@
 		}
 		return;
 	}
+#endif
+
+	if (cgs.gametype >= GT_TEAM  &&  !(cent->currentState.eFlags & EF_DEAD)) {
+		if (wolfcam_following) {
+			if (team == cgs.clientinfo[wcg.clientNum].team) {
+				if (cg_drawFriend.integer) {
+					CG_PlayerFloatSprite(cent, cgs.media.friendShader);
+					return;
+				}
+			}
+		} else if (cg.snap->ps.persistant[PERS_TEAM] == team) {
+			if (cg_drawFriend.integer) {
+				CG_PlayerFloatSprite(cent, cgs.media.friendShader);
+				return;
+			}
+		}
+	}
 }
 
 /*
@@ -2025,7 +2094,7 @@
 	// fade the shadow out with height
 	alpha = 1.0 - trace.fraction;
 
-	// hack / FPE - bogus planes?
+	// bk0101022 - hack / FPE - bogus planes?
 	//assert( DotProduct( trace.plane.normal, trace.plane.normal ) != 0.0f ) 
 
 	// add the mark as a temporary, so it goes directly to the renderer
@@ -2170,6 +2239,16 @@
 			ent->customShader = cgs.media.battleSuitShader;
 			trap_R_AddRefEntityToScene( ent );
 		}
+
+		if (wolfcam_wh.integer) {
+			ent->renderfx |= RF_DEPTHHACK;
+			ent->customShader = cgs.media.quadShader;
+			ent->shaderRGBA[0] = 0;
+			ent->shaderRGBA[1] = 0;
+			ent->shaderRGBA[2] = 255;
+			ent->shaderRGBA[3] = 125;
+			trap_R_AddRefEntityToScene( ent );
+		}
 	}
 }
 
@@ -2220,6 +2299,77 @@
 	return qtrue;
 }
 
+
+/*
+===================
+CG_CheckForEnemyModel
+===================
+*/
+
+static void CG_CheckForEnemyModel (int clientNum, clientInfo_t *ci, refEntity_t *legs, refEntity_t *torso, refEntity_t *head )
+{
+	if (clientNum == cg.clientNum) {
+		if (wolfcam_following  &&  clientNum != wcg.clientNum  &&  EM_Loaded == 1) {
+			// load enemy model for demo taker
+			CG_CopyClientInfoModel(&EM_ModelInfo, ci);
+		} else {
+			// revert back to original settings in case view had been changed
+			CG_CopyClientInfoModel(&cgs.clientinfoOrig[clientNum], ci);
+		}
+	} else if (wolfcam_following) {
+		if (clientNum == wcg.clientNum) {
+			// load original model for new player view
+			CG_CopyClientInfoModel(&cgs.clientinfoOrig[clientNum], ci);
+			//CG_Printf("orig %s\n", cgs.clientinfoOrig[clientNum].skinName);
+			return;
+		}
+
+		if (cgs.clientinfo[wcg.clientNum].team != ci->team  ||  cgs.gametype < GT_TEAM) {
+			if (EM_Loaded == 1) {
+				CG_CopyClientInfoModel(&EM_ModelInfo, ci);
+			}
+		}
+	} else if (cgs.clientinfo[cg.clientNum].team != ci->team  ||  cgs.gametype < GT_TEAM) {
+		if (EM_Loaded == 1) {
+			//Com_Printf("doing it\n");
+			CG_CopyClientInfoModel(&EM_ModelInfo, ci);
+		}
+	}
+
+	if (clientNum == cg.clientNum) {
+		if (wolfcam_following  &&  clientNum != wcg.clientNum  &&  EC_Loaded == 1) {
+			// set enemy colors for demo taker
+			memcpy(head->shaderRGBA, &EC_Colors[0], sizeof(EC_Colors));
+			memcpy(torso->shaderRGBA, &EC_Colors[1], sizeof(EC_Colors));
+			memcpy(legs->shaderRGBA, &EC_Colors[2], sizeof(EC_Colors));
+		}
+
+	} else if (wolfcam_following) {
+		if (clientNum == wcg.clientNum) {
+			//FIXME set original colors for new view -- not that important
+			return;
+		}
+
+		if (cgs.clientinfo[wcg.clientNum].team != ci->team  ||  cgs.gametype < GT_TEAM) {
+			if (EC_Loaded == 1) {
+				memcpy(head->shaderRGBA, &EC_Colors[0], sizeof(EC_Colors));
+				memcpy(torso->shaderRGBA, &EC_Colors[1], sizeof(EC_Colors));
+				memcpy(legs->shaderRGBA, &EC_Colors[2], sizeof(EC_Colors));
+			}
+		}
+	}
+	else if (cgs.clientinfo[cg.clientNum].team != ci->team  ||  cgs.gametype < GT_TEAM) {
+		if (EC_Loaded == 1) {
+			//Com_Printf("yes  %s\n", EM_ModelInfo.skinName);
+			memcpy(head->shaderRGBA, &EC_Colors[0], sizeof(EC_Colors));
+			memcpy(torso->shaderRGBA, &EC_Colors[1], sizeof(EC_Colors));
+			memcpy(legs->shaderRGBA, &EC_Colors[2], sizeof(EC_Colors));
+		}
+	} else {
+		//Com_Printf("diff teams\n");  // ok client info is messed up
+	}
+}
+
 /*
 ===============
 CG_Player
@@ -2227,6 +2377,7 @@
 */
 void CG_Player( centity_t *cent ) {
 	clientInfo_t	*ci;
+	clientInfo_t	cinfo;
 	refEntity_t		legs;
 	refEntity_t		torso;
 	refEntity_t		head;
@@ -2234,7 +2385,7 @@
 	int				renderfx;
 	qboolean		shadow;
 	float			shadowPlane;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	refEntity_t		skull;
 	refEntity_t		powerup;
 	int				t;
@@ -2250,7 +2401,10 @@
 	if ( clientNum < 0 || clientNum >= MAX_CLIENTS ) {
 		CG_Error( "Bad clientNum on player entity");
 	}
+	memcpy(&cinfo, &cgs.clientinfo[clientNum], sizeof(clientInfo_t));
 	ci = &cgs.clientinfo[ clientNum ];
+	//ci = &cinfo;
+	//Com_Printf("%d %d\n", clientNum, ci->team);
 
 	// it is possible to see corpses from disconnected players that may
 	// not have valid clientinfo
@@ -2258,6 +2412,33 @@
 		return;
 	}
 
+	//if (wolfcam_following  &&  clientNum == wcg.clientNum) {
+	//	return;
+	//}
+
+	memset( &legs, 0, sizeof(legs) );
+	memset( &torso, 0, sizeof(torso) );
+	memset( &head, 0, sizeof(head) );
+
+	CG_CheckForEnemyModel(clientNum, ci, &legs, &torso, &head);
+
+    if (wolfcam_following) {  //FIXME check that this is ok
+		//if (clientNum == wcg.clientNum) {
+		//	return;
+		//}
+
+        if (cent->currentState.eFlags & EF_NODRAW) {
+#if 0
+			CG_Printf ("not drawing client num %d  %s\n", clientNum,
+					   cgs.clientinfo[clientNum].name);
+#endif
+			//if (clientNum == wcg.clientNum)
+			//return;
+            return;
+			//cent->currentState.eFlags |= EF_NODRAW;
+		}
+    }
+
 	// get the player model information
 	renderfx = 0;
 	if ( cent->currentState.number == cg.snap->ps.clientNum) {
@@ -2270,11 +2451,6 @@
 		}
 	}
 
-
-	memset( &legs, 0, sizeof(legs) );
-	memset( &torso, 0, sizeof(torso) );
-	memset( &head, 0, sizeof(head) );
-
 	// get the rotation information
 	CG_PlayerAngles( cent, legs.axis, torso.axis, head.axis );
 	
@@ -2339,7 +2515,7 @@
 
 	CG_AddRefEntityWithPowerups( &torso, &cent->currentState, ci->team );
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	if ( cent->currentState.eFlags & EF_KAMIKAZE ) {
 
 		memset( &skull, 0, sizeof(skull) );
@@ -2541,7 +2717,7 @@
 		}
 		trap_R_AddRefEntityToScene( &powerup );
 	}
-#endif // MISSIONPACK
+#endif // MPACK
 
 	//
 	// add the head
@@ -2574,6 +2750,8 @@
 
 	// add powerups floating behind the player
 	CG_PlayerPowerups( cent, &torso );
+
+	//Wolfcam_AddBoundingBox (cent);
 }
 
 
diff -Naur cgame.orig/cg_playerstate.c cgame/cg_playerstate.c
--- cgame.orig/cg_playerstate.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_playerstate.c	2009-12-02 19:05:00.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_playerstate.c -- this file acts on changes in a new playerState_t
 // With normal play, this will be done after local prediction, but when
@@ -26,6 +6,7 @@
 // when the snapshot transitions like all the other entities
 
 #include "cg_local.h"
+#include "wolfcam_local.h"
 
 /*
 ==============
@@ -41,10 +22,10 @@
 	int		weapons;
 
 	// see about how many seconds of ammo we have remaining
-	weapons = cg.snap->ps.stats[ STAT_WEAPONS ];
+	weapons = cg.snap->ps.stats[ STAT_WEAPONS ];  //FIXME ok this seems to be broken
 	total = 0;
 	for ( i = WP_MACHINEGUN ; i < WP_NUM_WEAPONS ; i++ ) {
-		if ( ! ( weapons & ( 1 << i ) ) ) {
+		if ( ! ( weapons & ( 1 << i ) ) ) {  // this line looks fucked up when you are drunk
 			continue;
 		}
 		switch ( i ) {
@@ -52,7 +33,7 @@
 		case WP_GRENADE_LAUNCHER:
 		case WP_RAILGUN:
 		case WP_SHOTGUN:
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		case WP_PROX_LAUNCHER:
 #endif
 			total += cg.snap->ps.ammo[i] * 1000;
@@ -61,6 +42,7 @@
 			total += cg.snap->ps.ammo[i] * 200;
 			break;
 		}
+		//Com_Printf("FIXME testing ammo: total:%d  %d\n", total, cg.snap->ps.ammo[i]);
 		if ( total >= 5000 ) {
 			cg.lowAmmoWarning = 0;
 			return;
@@ -305,6 +287,8 @@
 
 	// hit changes
 	if ( ps->persistant[PERS_HITS] > ops->persistant[PERS_HITS] ) {
+		//Com_Printf(" hits:  %d  >  %d\n", ps->persistant[PERS_HITS], ops->persistant[PERS_HITS]);
+
 		armor  = ps->persistant[PERS_ATTACKEE_ARMOR] & 0xff;
 		health = ps->persistant[PERS_ATTACKEE_ARMOR] >> 8;
 #ifdef MISSIONPACK
@@ -316,7 +300,9 @@
 			trap_S_StartLocalSound( cgs.media.hitSound, CHAN_LOCAL_SOUND );
 		}
 #else
-		trap_S_StartLocalSound( cgs.media.hitSound, CHAN_LOCAL_SOUND );
+        //FIXME wolfcam-q3
+        if (!wolfcam_following) 
+            trap_S_StartLocalSound( cgs.media.hitSound, CHAN_LOCAL_SOUND );
 #endif
 	} else if ( ps->persistant[PERS_HITS] < ops->persistant[PERS_HITS] ) {
 		trap_S_StartLocalSound( cgs.media.hitTeamSound, CHAN_LOCAL_SOUND );
@@ -512,6 +498,7 @@
 	}
 
 	// check for going low on ammo
+	//Com_Printf("testing checking for low ammo\n");
 	CG_CheckAmmo();
 
 	// run events
diff -Naur cgame.orig/cg_predict.c cgame/cg_predict.c
--- cgame.orig/cg_predict.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_predict.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_predict.c -- this file generates cg.predictedPlayerState by either
 // interpolating between snapshots from the server or locally predicting
@@ -29,8 +9,11 @@
 
 static	pmove_t		cg_pmove;
 
-static	int			cg_numSolidEntities;
-static	centity_t	*cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
+//static	int			cg_numSolidEntities;
+int cg_numSolidEntities;
+
+//static	centity_t	*cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
+centity_t	*cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
 static	int			cg_numTriggerEntities;
 static	centity_t	*cg_triggerEntities[MAX_ENTITIES_IN_SNAPSHOT];
 
diff -Naur cgame.orig/cg_public.h cgame/cg_public.h
--- cgame.orig/cg_public.h	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_public.h	2007-08-24 12:36:36.000000000 -0400
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 
 
@@ -57,7 +37,8 @@
   CGAME_EVENT_NONE,
   CGAME_EVENT_TEAMMENU,
   CGAME_EVENT_SCOREBOARD,
-  CGAME_EVENT_EDITHUD
+  CGAME_EVENT_EDITHUD,
+  CGAME_EVENT_DEMO
 };
 
 
diff -Naur cgame.orig/cg_scoreboard.c cgame/cg_scoreboard.c
--- cgame.orig/cg_scoreboard.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_scoreboard.c	2009-11-29 18:09:16.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_scoreboard -- draw the scoreboard on top of the game screen
 #include "cg_local.h"
@@ -84,11 +64,30 @@
 	clientInfo_t	*ci;
 	int iconx, headx;
 
+#if 0
+	Com_Printf("----  CG_DrawClientScore()  ------\n");
+		Com_Printf("  client: %d\n", score->client);
+		Com_Printf("  score: %d\n", score->score);
+		Com_Printf("  ping:  %d\n", score->ping);
+		Com_Printf("  time: %d\n", score->time);
+		Com_Printf("  scoreFlags: %d\n", score->scoreFlags);
+		Com_Printf("  powerUps:  %d\n", score->powerUps);
+		Com_Printf("  accuracy:  %d\n", score->accuracy);
+		//		Com_Printf("  ...\n");
+		Com_Printf("  impressiveCount:  %d\n", score->impressiveCount);
+		Com_Printf("  excellentCount:  %d\n", score->excellentCount);
+		Com_Printf("  guantletCount:  %d\n", score->guantletCount);
+		Com_Printf("  defendCount:  %d\n", score->defendCount);
+		Com_Printf("  assistCount:  %d\n", score->assistCount);
+		Com_Printf("  perfect:  %d\n", score->perfect);
+		Com_Printf("  team:  %d\n", score->team);
+#endif
+
 	if ( score->client < 0 || score->client >= cgs.maxclients ) {
 		Com_Printf( "Bad score->client: %i\n", score->client );
 		return;
 	}
-	
+
 	ci = &cgs.clientinfo[score->client];
 
 	iconx = SB_BOTICON_X + (SB_RATING_WIDTH / 2);
@@ -174,7 +173,7 @@
 			" connecting    %s", ci->name);
 	} else if ( ci->team == TEAM_SPECTATOR ) {
 		Com_sprintf(string, sizeof(string),
-			" SPECT %3i %4i %s", score->ping, score->time, ci->name);
+			"^3%5i %4i %4i ^7%s", score->score, score->ping, score->time, ci->name);
 	} else {
 		Com_sprintf(string, sizeof(string),
 			"%5i %4i %4i %s", score->score, score->ping, score->time, ci->name);
diff -Naur cgame.orig/cg_servercmds.c cgame/cg_servercmds.c
--- cgame.orig/cg_servercmds.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_servercmds.c	2009-12-05 00:57:16.000000000 -0500
@@ -1,31 +1,12 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_servercmds.c -- reliably sequenced text commands sent by the server
 // these are processed at snapshot transition time, so there will definately
 // be a valid snapshot this frame
 
 #include "cg_local.h"
-#include "../../ui/menudef.h"
+#include "../../ui/menudef.h" // bk001205 - for Q3_ui as well
+#include "wolfcam_local.h"
 
 typedef struct {
 	const char *order;
@@ -46,7 +27,7 @@
 
 static const int numValidOrders = sizeof(validOrders) / sizeof(orderTask_t);
 
-#ifdef MISSIONPACK
+#ifdef MISSIONPACK // bk001204
 static int CG_ValidOrder(const char *p) {
 	int i;
 	for (i = 0; i < numValidOrders; i++) {
@@ -76,22 +57,25 @@
 	cg.teamScores[1] = atoi( CG_Argv( 3 ) );
 
 	memset( cg.scores, 0, sizeof( cg.scores ) );
+#define SCSIZE 18  // was 14
+
 	for ( i = 0 ; i < cg.numScores ; i++ ) {
 		//
-		cg.scores[i].client = atoi( CG_Argv( i * 14 + 4 ) );
-		cg.scores[i].score = atoi( CG_Argv( i * 14 + 5 ) );
-		cg.scores[i].ping = atoi( CG_Argv( i * 14 + 6 ) );
-		cg.scores[i].time = atoi( CG_Argv( i * 14 + 7 ) );
-		cg.scores[i].scoreFlags = atoi( CG_Argv( i * 14 + 8 ) );
-		powerups = atoi( CG_Argv( i * 14 + 9 ) );
-		cg.scores[i].accuracy = atoi(CG_Argv(i * 14 + 10));
-		cg.scores[i].impressiveCount = atoi(CG_Argv(i * 14 + 11));
-		cg.scores[i].excellentCount = atoi(CG_Argv(i * 14 + 12));
-		cg.scores[i].guantletCount = atoi(CG_Argv(i * 14 + 13));
-		cg.scores[i].defendCount = atoi(CG_Argv(i * 14 + 14));
-		cg.scores[i].assistCount = atoi(CG_Argv(i * 14 + 15));
-		cg.scores[i].perfect = atoi(CG_Argv(i * 14 + 16));
-		cg.scores[i].captures = atoi(CG_Argv(i * 14 + 17));
+		cg.scores[i].client = atoi( CG_Argv( i * SCSIZE + 4 ) );
+		cg.scores[i].score = atoi( CG_Argv( i * SCSIZE + 5 ) );
+		cg.scores[i].ping = atoi( CG_Argv( i * SCSIZE + 6 ) );
+		cg.scores[i].time = atoi( CG_Argv( i * SCSIZE + 7 ) );
+		cg.scores[i].scoreFlags = atoi( CG_Argv( i * SCSIZE + 8 ) );
+		powerups = atoi( CG_Argv( i * SCSIZE + 9 ) );
+		cg.scores[i].accuracy = atoi(CG_Argv(i * SCSIZE + 10));
+		cg.scores[i].impressiveCount = atoi(CG_Argv(i * SCSIZE + 11));
+		cg.scores[i].excellentCount = atoi(CG_Argv(i * SCSIZE + 12));
+		cg.scores[i].guantletCount = atoi(CG_Argv(i * SCSIZE + 13));
+		cg.scores[i].defendCount = atoi(CG_Argv(i * SCSIZE + 14));
+		cg.scores[i].assistCount = atoi(CG_Argv(i * SCSIZE + 15));
+		cg.scores[i].perfect = atoi(CG_Argv(i * SCSIZE + 16));
+		cg.scores[i].captures = atoi(CG_Argv(i * SCSIZE + 17));
+		//FIXME last 4 unknown ones
 
 		if ( cg.scores[i].client < 0 || cg.scores[i].client >= MAX_CLIENTS ) {
 			cg.scores[i].client = 0;
@@ -104,7 +88,7 @@
 #ifdef MISSIONPACK
 	CG_SetScoreSelection(NULL);
 #endif
-
+#undef SCSIZE
 }
 
 /*
@@ -118,20 +102,9 @@
 	int		client;
 
 	numSortedTeamPlayers = atoi( CG_Argv( 1 ) );
-	if( numSortedTeamPlayers < 0 || numSortedTeamPlayers > TEAM_MAXOVERLAY )
-	{
-		CG_Error( "CG_ParseTeamInfo: numSortedTeamPlayers out of range (%d)",
-				numSortedTeamPlayers );
-		return;
-	}
 
 	for ( i = 0 ; i < numSortedTeamPlayers ; i++ ) {
 		client = atoi( CG_Argv( i * 6 + 2 ) );
-		if( client < 0 || client >= MAX_CLIENTS )
-		{
-		  CG_Error( "CG_ParseTeamInfo: bad client number: %d", client );
-		  return;
-		}
 
 		sortedTeamPlayers[i] = client;
 
@@ -289,6 +262,8 @@
 	// look up the individual string that was modified
 	str = CG_ConfigString( num );
 
+	//CG_Printf("config string modfied  %d: %s\n", num, str);
+
 	// do something with it if necessary
 	if ( num == CS_MUSIC ) {
 		CG_StartMusic();
@@ -332,10 +307,15 @@
 #endif
 	} else if ( num == CS_INTERMISSION ) {
 		cg.intermissionStarted = atoi( str );
-	} else if ( num >= CS_MODELS && num < CS_MODELS+MAX_MODELS ) {
+        //Wolfcam_Weapon_Statsall_f ();
+        trap_SendConsoleCommand ("vstr wolfcam_execIntermission");
+		//	} else if ( num >= CS_MODELS && num < CS_MODELS+MAX_MODELS ) {
+	} else if (num >= CS_MODELS  &&  num < CS_SOUNDS) {
 		cgs.gameModels[ num-CS_MODELS ] = trap_R_RegisterModel( str );
-	} else if ( num >= CS_SOUNDS && num < CS_SOUNDS+MAX_SOUNDS ) {
+		//	} else if ( num >= CS_SOUNDS && num < CS_SOUNDS+MAX_MODELS ) {
+	} else if (num >= CS_SOUNDS  &&  num < CS_PLAYERS) {
 		if ( str[0] != '*' ) {	// player specific sounds don't register here
+			CG_Printf("server says to play sound %d (%d): %s\n", num, num - CS_SOUNDS, str);
 			cgs.gameSounds[ num-CS_SOUNDS] = trap_S_RegisterSound( str, qfalse );
 		}
 	} else if ( num >= CS_PLAYERS && num < CS_PLAYERS+MAX_CLIENTS ) {
@@ -355,8 +335,14 @@
 	}
 	else if ( num == CS_SHADERSTATE ) {
 		CG_ShaderStateChanged();
+	} else if (num == CS_FIRSTPLACE) {
+	} else if (num == CS_SECONDPLACE) {
+	} else if (num == CS_SYSTEMINFO) {
+	}
+
+	else {
+		CG_Printf("unknown config string modified  %d: %s\n", num, str);
 	}
-		
 }
 
 
@@ -968,6 +954,21 @@
 */
 static void CG_RemoveChatEscapeChar( char *text ) {
 	int i, l;
+	int len;
+	char orig[MAX_STRING_CHARS];
+
+	if (!text)
+		return;
+
+	len = strlen(text);
+	if (len >= MAX_STRING_CHARS) {
+		Com_Printf("chat string too long\n");
+		text[0] = '\0';
+		return;
+	}
+
+	if (len < 3)
+		return;
 
 	l = 0;
 	for ( i = 0; text[i]; i++ ) {
@@ -976,6 +977,10 @@
 		text[l++] = text[i];
 	}
 	text[l] = '\0';
+
+	// remove player numbers
+	Q_strncpyz(orig, text, len);
+	Q_strncpyz(text, orig + 3, len - 3);
 }
 
 /*
@@ -1056,6 +1061,7 @@
 
 	if ( !strcmp( cmd, "scores" ) ) {
 		CG_ParseScores();
+		Wolfcam_ScoreData();
 		return;
 	}
 
@@ -1069,22 +1075,10 @@
 		return;
 	}
 
-	if ( Q_stricmp (cmd, "remapShader") == 0 )
-	{
-		if (trap_Argc() == 4)
-		{
-			char shader1[MAX_QPATH];
-			char shader2[MAX_QPATH];
-			char shader3[MAX_QPATH];
-
-			Q_strncpyz(shader1, CG_Argv(1), sizeof(shader1));
-			Q_strncpyz(shader2, CG_Argv(2), sizeof(shader2));
-			Q_strncpyz(shader3, CG_Argv(3), sizeof(shader3));
-
-			trap_R_RemapShader(shader1, shader2, shader3);
+  if ( Q_stricmp (cmd, "remapShader") == 0 ) {
+		if (trap_Argc() == 4) {
+			trap_R_RemapShader(CG_Argv(1), CG_Argv(2), CG_Argv(3));
 		}
-		
-		return;
 	}
 
 	// loaddeferred can be both a servercmd and a consolecmd
@@ -1101,6 +1095,11 @@
 	}
 
 	CG_Printf( "Unknown client game command: %s\n", cmd );
+	CG_Printf ("argv[1]: %s\n", CG_Argv(1));
+	CG_Printf ("argv[2]: %s\n", CG_Argv(2));
+	CG_Printf ("argv[3]: %s\n", CG_Argv(3));
+	CG_Printf ("argv[4]: %s\n", CG_Argv(4));
+	CG_Printf ("argv[5]: %s\n", CG_Argv(5));
 }
 
 
diff -Naur cgame.orig/cg_snapshot.c cgame/cg_snapshot.c
--- cgame.orig/cg_snapshot.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_snapshot.c	2007-08-24 12:36:36.000000000 -0400
@@ -1,30 +1,10 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_snapshot.c -- things that happen on snapshot transition,
 // not necessarily every single rendered frame
 
 #include "cg_local.h"
-
+#include "wolfcam_local.h"
 
 
 /*
@@ -90,6 +70,9 @@
 
 	cg.snap = snap;
 
+    memcpy (&wcg.snaps[wcg.curSnapshotNumber & MAX_SNAPSHOT_MASK], snap, sizeof(snapshot_t));
+    wcg.curSnapshotNumber++;
+
 	BG_PlayerStateToEntityState( &snap->ps, &cg_entities[ snap->ps.clientNum ].currentState, qfalse );
 
 	// sort out solid entities
@@ -159,6 +142,16 @@
 
 	for ( i = 0 ; i < cg.snap->numEntities ; i++ ) {
 		cent = &cg_entities[ cg.snap->entities[ i ].number ];
+        if (cg.snap->entities[i].number < MAX_CLIENTS) {
+            memcpy (&wclients[cg.snap->entities[i].number].oldState, &cg_entities[cg.snap->entities[i].number].currentState, sizeof (entityState_t));
+#if 0
+			CG_Printf ("%d  %f %f %f\n", cg.snap->entities[i].number,
+					   cg.snap->entities[i].pos.trBase[0],
+					   cg.snap->entities[i].pos.trBase[1],
+					   cg.snap->entities[i].pos.trBase[2]
+					   );
+#endif
+        }
 		CG_TransitionEntity( cent );
 
 		// remember time of snapshot this entity was last updated in
@@ -203,6 +196,28 @@
 
 	cg.nextSnap = snap;
 
+    if (cg.snap) {
+        memcpy (&wcg.snaps[wcg.curSnapshotNumber & MAX_SNAPSHOT_MASK], cg.snap,sizeof(snapshot_t));
+        wcg.curSnapshotNumber++;
+        Wolfcam_NextSnapShotSet ();
+    }
+
+    if (cg.snap) {
+		int oldTime;
+
+		oldTime = wcg.snaps[(wcg.curSnapshotNumber - 1) & MAX_SNAPSHOT_MASK].serverTime;
+		if (cg.snap->serverTime - oldTime > 33) {
+			//CG_Printf ("%d\n", cg.snap->serverTime - oldTime);
+		}
+        //memcpy (&wcg.oldSnap, cg.snap, sizeof (snapshot_t));
+        //wcg.oldSnapValid = qtrue;
+        //memcpy (&wcg.snaps[wcg.curSnapshotNumber & MAX_SNAPSHOT_MASK], cg.snap, sizeof(snapshot_t));
+        //wcg.curSnapshotNumber++;
+        //CG_Printf ("snapshot: %d\n", wcg.curSnapshotNumber);
+    } else {
+        //wcg.oldSnapValid = qfalse;
+    }
+
 	BG_PlayerStateToEntityState( &snap->ps, &cg_entities[ snap->ps.clientNum ].nextState, qfalse );
 	cg_entities[ cg.snap->ps.clientNum ].interpolate = qtrue;
 
diff -Naur cgame.orig/cg_syscalls.c cgame/cg_syscalls.c
--- cgame.orig/cg_syscalls.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_syscalls.c	2009-12-06 16:40:25.000000000 -0500
@@ -1,24 +1,4 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_syscalls.c -- this file is only included when building a dll
 // cg_syscalls.asm is included instead when building a qvm
@@ -28,18 +8,18 @@
 
 #include "cg_local.h"
 
-static intptr_t (QDECL *syscall)( intptr_t arg, ... ) = (intptr_t (QDECL *)( intptr_t, ...))-1;
+static intptr_t (QDECL *syscall)( intptr_t arg, ... ) = (int (QDECL *)( intptr_t, ...))-1;
 
 
-Q_EXPORT void dllEntry( intptr_t (QDECL  *syscallptr)( intptr_t arg,... ) ) {
+Q_EXPORT void dllEntry( int (QDECL  *syscallptr)( intptr_t arg,... ) ) {
 	syscall = syscallptr;
 }
 
 
 int PASSFLOAT( float x ) {
-	floatint_t fi;
-	fi.f = x;
-	return fi.i;
+	float	floatTemp;
+	floatTemp = x;
+	return *(int *)&floatTemp;
 }
 
 void	trap_Print( const char *fmt ) {
diff -Naur cgame.orig/cg_view.c cgame/cg_view.c
--- cgame.orig/cg_view.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_view.c	2009-12-05 18:07:22.000000000 -0500
@@ -1,28 +1,9 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_view.c -- setup all the parameters (position, angle, etc)
 // for a 3D rendering
 #include "cg_local.h"
+#include "wolfcam_local.h"
 
 
 /*
@@ -749,6 +730,24 @@
 	}
 }
 
+#if 0
+static void Wolfcam_Stall (unsigned int ticks)
+{
+    int i;
+    int x;
+    //qtime_t ct;
+
+    x = 600;
+
+    for (i = 0;  i < ticks;  i++) {
+        if (i % 2 == 0)
+            x++;
+        else
+            x--;
+    }
+}
+#endif
+
 //=========================================================================
 
 /*
@@ -759,7 +758,9 @@
 =================
 */
 void CG_DrawActiveFrame( int serverTime, stereoFrame_t stereoView, qboolean demoPlayback ) {
-	int		inwater;
+	int		inwater = qfalse;
+
+    //CG_Printf ("CG_DrawActiveFrame: serverTime:%d\n", serverTime);
 
 	cg.time = serverTime;
 	cg.demoPlayback = demoPlayback;
@@ -804,16 +805,86 @@
 	cg.renderingThirdPerson = cg_thirdPerson.integer || (cg.snap->ps.stats[STAT_HEALTH] <= 0);
 
 	// build cg.refdef
-	inwater = CG_CalcViewValues();
+    if (!wolfcam_following)
+        inwater = CG_CalcViewValues();
+
+	Wolfcam_LoadModels();
 
 	// first person blend blobs, done after AnglesToAxis
-	if ( !cg.renderingThirdPerson ) {
+	if (!wolfcam_following  &&  !cg.renderingThirdPerson) {
 		CG_DamageBlendBlob();
-	}
+	} else if (wolfcam_following  &&  !(cg_entities[wcg.clientNum].currentState.eFlags & EF_DEAD)) {
+        //Wolfcam_DamageBlendBlob ();
+    }
 
 	// build the render lists
 	if ( !cg.hyperspace ) {
 		CG_AddPacketEntities();			// adter calcViewValues, so predicted player state is correct
+        Wolfcam_MarkValidEntities ();
+		//Com_Printf("cgs.gametype: %d\n", cgs.gametype);
+		// cg.snap->ps.persistant[PERS_HWEAPON_USE]
+#if 0  // these seem ok
+		Com_Printf("score:%d  hits:%d  rank:%d  team:%d  spawnCount:%d\n", 
+				   cg.snap->ps.persistant[PERS_SCORE],
+				   cg.snap->ps.persistant[PERS_HITS],
+				   cg.snap->ps.persistant[PERS_RANK],
+				   cg.snap->ps.persistant[PERS_TEAM],
+				   cg.snap->ps.persistant[PERS_SPAWN_COUNT]);
+#endif
+
+#if 0  // ATTACKEE_ARMOR is wrong
+		Com_Printf("playerEvents:%d  attacker:%d  killed:%d  imCount:%d\n", 
+				   cg.snap->ps.persistant[PERS_PLAYEREVENTS],
+				   cg.snap->ps.persistant[PERS_ATTACKER],
+				   //cg.snap->ps.persistant[PERS_ATTACKEE_ARMOR],
+				   cg.snap->ps.persistant[PERS_KILLED],
+				   cg.snap->ps.persistant[PERS_IMPRESSIVE_COUNT]);
+#endif
+
+#if 0
+		Com_Printf("exCount:%d  defendCount:%d  assistCount:%d  gauntFragCount:%d  attArmor:%d\n", 
+				   cg.snap->ps.persistant[PERS_EXCELLENT_COUNT],
+				   cg.snap->ps.persistant[PERS_DEFEND_COUNT],
+				   cg.snap->ps.persistant[PERS_ASSIST_COUNT],
+				   cg.snap->ps.persistant[PERS_GAUNTLET_FRAG_COUNT],
+				   cg.snap->ps.persistant[PERS_CAPTURES],
+				   cg.snap->ps.persistant[PERS_ATTACKEE_ARMOR]);
+#endif
+
+        if (wolfcam_following) {
+			//Wolfcam_SwitchPlayerModels();
+			//FIXME player models and also select client to view should happen before CG_AddPacketEntities()  -- probable cause of flashing when changing views
+            Wolfcam_TransitionPlayerState ();
+			Wolfcam_OffsetFirstPersonView ();
+			if (wolfcam_fixedViewAngles.integer > 0) {
+				static int oldTime = 0;
+				static vec3_t oldViewAngles = { 0.0f, 0.0f, 0.0f };
+				//static vec3_t oldViewaxis = { 0.0f, 0.0f, 0.0f };
+				
+				if (cg.time - oldTime > wolfcam_fixedViewAngles.integer) {
+					VectorCopy (cg.refdefViewAngles, oldViewAngles);
+					//VectorCopy (cg.refdef.viewaxis, oldViewaxis);
+					oldTime = cg.time;
+					//CG_Printf ("new angle\n");
+				} else {
+					//CG_Printf ("using old %f %f %f\n", oldViewAngles);
+				}
+
+				VectorCopy (oldViewAngles, cg.refdefViewAngles);
+				//VectorCopy (oldViewaxis, cg.refdef.viewaxis);
+				AnglesToAxis (cg.refdefViewAngles, cg.refdef.viewaxis);
+			} 
+
+#if 0
+            if (cg_entities[wcg.clientNum].currentState.eFlags & EF_DEAD)
+                Wolfcam_OffsetThirdPersonView ();
+            else {
+                Wolfcam_OffsetFirstPersonView ();
+                //Wolfcam_DamageBlendBlob ();  //FIXME wolfcam
+            }
+#endif
+            inwater = Wolfcam_CalcFov ();
+        }
 		CG_AddMarks();
 		CG_AddParticles ();
 		CG_AddLocalEntities();
@@ -837,7 +908,14 @@
 	CG_PowerupTimerSounds();
 
 	// update audio positions
-	trap_S_Respatialize( cg.snap->ps.clientNum, cg.refdef.vieworg, cg.refdef.viewaxis, inwater );
+    if (wolfcam_following) {
+        if (wcg.playHitSound) {
+            trap_S_StartLocalSound (cgs.media.hitSound, CHAN_LOCAL_SOUND);
+            wcg.playHitSound = qfalse;
+        }
+        trap_S_Respatialize (wcg.clientNum, cg.refdef.vieworg, cg.refdef.viewaxis, inwater);
+    } else
+        trap_S_Respatialize( cg.snap->ps.clientNum, cg.refdef.vieworg, cg.refdef.viewaxis, inwater );
 
 	// make sure the lagometerSample and frame timing isn't done twice when in stereo
 	if ( stereoView != STEREO_RIGHT ) {
@@ -871,6 +949,7 @@
 		CG_Printf( "cg.clientFrame:%i\n", cg.clientFrame );
 	}
 
-
+    //if (cg_timescale.value < 0.1) 
+        //Wolfcam_Stall (1073741824 / 4);
 }
 
diff -Naur cgame.orig/cg_weapons.c cgame/cg_weapons.c
--- cgame.orig/cg_weapons.c	2009-12-05 01:55:28.000000000 -0500
+++ cgame/cg_weapons.c	2009-12-05 18:08:01.000000000 -0500
@@ -1,27 +1,10 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Quake III Arena source code.
-
-Quake III Arena source code is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Quake III Arena source code is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Quake III Arena source code; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
+// Copyright (C) 1999-2000 Id Software, Inc.
 //
 // cg_weapons.c -- events and effects dealing with weapons
 #include "cg_local.h"
+#include "wolfcam_local.h"
+
+static qboolean CG_CalcMuzzlePoint( int entityNum, vec3_t muzzle );
 
 /*
 ==========================
@@ -173,7 +156,7 @@
 }
 
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 /*
 ==========================
 CG_NailgunEjectBrass
@@ -225,6 +208,13 @@
 #define SPACING  5
  
 	start[2] -= 4;
+	VectorCopy (start, move);
+	VectorSubtract (end, start, vec);
+	len = VectorNormalize (vec);
+	PerpendicularVector(temp, vec);
+	for (i = 0 ; i < 36; i++) {
+		RotatePointAroundVector(axis[i], vec, temp, i * 10);//banshee 2.4 was 10
+	}
  
 	le = CG_AllocLocalEntity();
 	re = &le->refEntity;
@@ -240,12 +230,13 @@
  
 	VectorCopy(start, re->origin);
 	VectorCopy(end, re->oldorigin);
- 
-	re->shaderRGBA[0] = ci->color1[0] * 255;
-	re->shaderRGBA[1] = ci->color1[1] * 255;
-	re->shaderRGBA[2] = ci->color1[2] * 255;
-	re->shaderRGBA[3] = 255;
 
+#if 1
+	re->shaderRGBA[0] = ci->color1[0] * 255;
+    re->shaderRGBA[1] = ci->color1[1] * 255;
+    re->shaderRGBA[2] = ci->color1[2] * 255;
+    re->shaderRGBA[3] = 255;
+#endif
 	le->color[0] = ci->color1[0] * 0.75;
 	le->color[1] = ci->color1[1] * 0.75;
 	le->color[2] = ci->color1[2] * 0.75;
@@ -253,73 +244,60 @@
 
 	AxisClear( re->axis );
  
-	if (cg_oldRail.integer)
-	{
+	VectorMA(move, 20, vec, move);
+	VectorCopy(move, next_move);
+	VectorScale (vec, SPACING, vec);
+
+	if (cg_oldRail.integer != 0) {
 		// nudge down a bit so it isn't exactly in center
 		re->origin[2] -= 8;
 		re->oldorigin[2] -= 8;
 		return;
 	}
-
-	VectorCopy (start, move);
-	VectorSubtract (end, start, vec);
-	len = VectorNormalize (vec);
-	PerpendicularVector(temp, vec);
-	for (i = 0 ; i < 36; i++)
-	{
-		RotatePointAroundVector(axis[i], vec, temp, i * 10);//banshee 2.4 was 10
-	}
-
-	VectorMA(move, 20, vec, move);
-	VectorCopy(move, next_move);
-	VectorScale (vec, SPACING, vec);
-
 	skip = -1;
  
 	j = 18;
-	for (i = 0; i < len; i += SPACING)
-	{
-		if (i != skip)
-		{
+    for (i = 0; i < len; i += SPACING) {
+		if (i != skip) {
 			skip = i + SPACING;
 			le = CG_AllocLocalEntity();
-			re = &le->refEntity;
-			le->leFlags = LEF_PUFF_DONT_SCALE;
+            re = &le->refEntity;
+            le->leFlags = LEF_PUFF_DONT_SCALE;
 			le->leType = LE_MOVE_SCALE_FADE;
-			le->startTime = cg.time;
-			le->endTime = cg.time + (i>>1) + 600;
-			le->lifeRate = 1.0 / (le->endTime - le->startTime);
-
-			re->shaderTime = cg.time / 1000.0f;
-			re->reType = RT_SPRITE;
-			re->radius = 1.1f;
+            le->startTime = cg.time;
+            le->endTime = cg.time + (i>>1) + 600;
+            le->lifeRate = 1.0 / (le->endTime - le->startTime);
+
+            re->shaderTime = cg.time / 1000.0f;
+            re->reType = RT_SPRITE;
+            re->radius = 1.1f;
 			re->customShader = cgs.media.railRingsShader;
 
-			re->shaderRGBA[0] = ci->color2[0] * 255;
-			re->shaderRGBA[1] = ci->color2[1] * 255;
-			re->shaderRGBA[2] = ci->color2[2] * 255;
-			re->shaderRGBA[3] = 255;
-
-			le->color[0] = ci->color2[0] * 0.75;
-			le->color[1] = ci->color2[1] * 0.75;
-			le->color[2] = ci->color2[2] * 0.75;
-			le->color[3] = 1.0f;
+            re->shaderRGBA[0] = ci->color2[0] * 255;
+            re->shaderRGBA[1] = ci->color2[1] * 255;
+            re->shaderRGBA[2] = ci->color2[2] * 255;
+            re->shaderRGBA[3] = 255;
+
+            le->color[0] = ci->color2[0] * 0.75;
+            le->color[1] = ci->color2[1] * 0.75;
+            le->color[2] = ci->color2[2] * 0.75;
+            le->color[3] = 1.0f;
 
-			le->pos.trType = TR_LINEAR;
-			le->pos.trTime = cg.time;
+            le->pos.trType = TR_LINEAR;
+            le->pos.trTime = cg.time;
 
 			VectorCopy( move, move2);
-			VectorMA(move2, RADIUS , axis[j], move2);
-			VectorCopy(move2, le->pos.trBase);
+            VectorMA(move2, RADIUS , axis[j], move2);
+            VectorCopy(move2, le->pos.trBase);
 
-			le->pos.trDelta[0] = axis[j][0]*6;
-			le->pos.trDelta[1] = axis[j][1]*6;
-			le->pos.trDelta[2] = axis[j][2]*6;
+            le->pos.trDelta[0] = axis[j][0]*6;
+            le->pos.trDelta[1] = axis[j][1]*6;
+            le->pos.trDelta[2] = axis[j][2]*6;
 		}
 
-		VectorAdd (move, vec, move);
+        VectorAdd (move, vec, move);
 
-		j = (j + ROTATION) % 36;
+        j = j + ROTATION < 36 ? j + ROTATION : (j + ROTATION) % 36;
 	}
 }
 
@@ -390,7 +368,7 @@
 
 }
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 /*
 ==========================
 CG_NailTrail
@@ -662,17 +640,17 @@
 	}
 
 	strcpy( path, item->world_model[0] );
-	COM_StripExtension(path, path, sizeof(path));
+	COM_StripExtension( path, path, sizeof(path) );
 	strcat( path, "_flash.md3" );
 	weaponInfo->flashModel = trap_R_RegisterModel( path );
 
 	strcpy( path, item->world_model[0] );
-	COM_StripExtension(path, path, sizeof(path));
+	COM_StripExtension( path, path, sizeof(path) );
 	strcat( path, "_barrel.md3" );
 	weaponInfo->barrelModel = trap_R_RegisterModel( path );
 
 	strcpy( path, item->world_model[0] );
-	COM_StripExtension(path, path, sizeof(path));
+	COM_StripExtension( path, path, sizeof(path) );
 	strcat( path, "_hand.md3" );
 	weaponInfo->handsModel = trap_R_RegisterModel( path );
 
@@ -695,7 +673,8 @@
 		weaponInfo->firingSound = trap_S_RegisterSound( "sound/weapons/lightning/lg_hum.wav", qfalse );
 
 		weaponInfo->flashSound[0] = trap_S_RegisterSound( "sound/weapons/lightning/lg_fire.wav", qfalse );
-		cgs.media.lightningShader = trap_R_RegisterShader( "lightningBoltNew");
+		//cgs.media.lightningShader = trap_R_RegisterShader( "lightningBoltNew");
+		cgs.media.lightningShader = trap_R_RegisterShader( "lightningBolt1");
 		cgs.media.lightningExplosionModel = trap_R_RegisterModel( "models/weaphits/crackle.md3" );
 		cgs.media.sfx_lghit1 = trap_S_RegisterSound( "sound/weapons/lightning/lg_hit.wav", qfalse );
 		cgs.media.sfx_lghit2 = trap_S_RegisterSound( "sound/weapons/lightning/lg_hit2.wav", qfalse );
@@ -715,7 +694,7 @@
 		weaponInfo->firingSound = trap_S_RegisterSound( "sound/weapons/melee/fstrun.wav", qfalse );
 		break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_CHAINGUN:
 		weaponInfo->firingSound = trap_S_RegisterSound( "sound/weapons/vulcan/wvulfire.wav", qfalse );
 		weaponInfo->loopFireSound = qtrue;
@@ -760,7 +739,7 @@
 		cgs.media.rocketExplosionShader = trap_R_RegisterShader( "rocketExplosion" );
 		break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_PROX_LAUNCHER:
 		weaponInfo->missileModel = trap_R_RegisterModel( "models/weaphits/proxmine.md3" );
 		weaponInfo->missileTrailFunc = CG_GrenadeTrail;
@@ -782,7 +761,7 @@
 		cgs.media.grenadeExplosionShader = trap_R_RegisterShader( "grenadeExplosion" );
 		break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_NAILGUN:
 		weaponInfo->ejectBrassFunc = CG_NailgunEjectBrass;
 		weaponInfo->missileTrailFunc = CG_NailTrail;
@@ -1180,7 +1159,7 @@
 		cent->pe.barrelTime = cg.time;
 		cent->pe.barrelAngle = AngleMod( angle );
 		cent->pe.barrelSpinning = !!(cent->currentState.eFlags & EF_FIRING);
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 		if ( cent->currentState.weapon == WP_CHAINGUN && !cent->pe.barrelSpinning ) {
 			trap_S_StartSound( NULL, cent->currentState.number, CHAN_WEAPON, trap_S_RegisterSound( "sound/weapons/vulcan/wvulwind.wav", qfalse ) );
 		}
@@ -1233,7 +1212,7 @@
 	weapon_t	weaponNum;
 	weaponInfo_t	*weapon;
 	centity_t	*nonPredictedCent;
-	orientation_t	lerped;
+//	int	col;
 
 	weaponNum = cent->currentState.weapon;
 
@@ -1281,22 +1260,7 @@
 		}
 	}
 
-	trap_R_LerpTag(&lerped, parent->hModel, parent->oldframe, parent->frame,
-		1.0 - parent->backlerp, "tag_weapon");
-	VectorCopy(parent->origin, gun.origin);
-
-	VectorMA(gun.origin, lerped.origin[0], parent->axis[0], gun.origin);
-
-	// Make weapon appear left-handed for 2 and centered for 3
-	if(ps && cg_drawGun.integer == 2)
-		VectorMA(gun.origin, -lerped.origin[1], parent->axis[1], gun.origin);
-	else if(!ps || cg_drawGun.integer != 3)
-       	VectorMA(gun.origin, lerped.origin[1], parent->axis[1], gun.origin);
-
-	VectorMA(gun.origin, lerped.origin[2], parent->axis[2], gun.origin);
-
-	MatrixMultiply(lerped.axis, ((refEntity_t *)parent)->axis, gun.axis);
-	gun.backlerp = parent->backlerp;
+	CG_PositionEntityOnTag( &gun, parent, parent->hModel, "tag_weapon");
 
 	CG_AddWeaponWithPowerups( &gun, cent->currentState.powerups );
 
@@ -1510,7 +1474,7 @@
 	// count the number of weapons owned
 	bits = cg.snap->ps.stats[ STAT_WEAPONS ];
 	count = 0;
-	for ( i = 1 ; i < MAX_WEAPONS ; i++ ) {
+	for ( i = 1 ; i < 16 ; i++ ) {
 		if ( bits & ( 1 << i ) ) {
 			count++;
 		}
@@ -1519,7 +1483,7 @@
 	x = 320 - count * 20;
 	y = 380;
 
-	for ( i = 1 ; i < MAX_WEAPONS ; i++ ) {
+	for ( i = 1 ; i < 16 ; i++ ) {
 		if ( !( bits & ( 1 << i ) ) ) {
 			continue;
 		}
@@ -1591,9 +1555,9 @@
 	cg.weaponSelectTime = cg.time;
 	original = cg.weaponSelect;
 
-	for ( i = 0 ; i < MAX_WEAPONS ; i++ ) {
+	for ( i = 0 ; i < 16 ; i++ ) {
 		cg.weaponSelect++;
-		if ( cg.weaponSelect == MAX_WEAPONS ) {
+		if ( cg.weaponSelect == 16 ) {
 			cg.weaponSelect = 0;
 		}
 		if ( cg.weaponSelect == WP_GAUNTLET ) {
@@ -1603,7 +1567,7 @@
 			break;
 		}
 	}
-	if ( i == MAX_WEAPONS ) {
+	if ( i == 16 ) {
 		cg.weaponSelect = original;
 	}
 }
@@ -1627,10 +1591,10 @@
 	cg.weaponSelectTime = cg.time;
 	original = cg.weaponSelect;
 
-	for ( i = 0 ; i < MAX_WEAPONS ; i++ ) {
+	for ( i = 0 ; i < 16 ; i++ ) {
 		cg.weaponSelect--;
 		if ( cg.weaponSelect == -1 ) {
-			cg.weaponSelect = MAX_WEAPONS - 1;
+			cg.weaponSelect = 15;
 		}
 		if ( cg.weaponSelect == WP_GAUNTLET ) {
 			continue;		// never cycle to gauntlet
@@ -1639,7 +1603,7 @@
 			break;
 		}
 	}
-	if ( i == MAX_WEAPONS ) {
+	if ( i == 16 ) {
 		cg.weaponSelect = original;
 	}
 }
@@ -1661,7 +1625,7 @@
 
 	num = atoi( CG_Argv( 1 ) );
 
-	if ( num < 1 || num > MAX_WEAPONS-1 ) {
+	if ( num < 1 || num > 15 ) {
 		return;
 	}
 
@@ -1686,7 +1650,7 @@
 
 	cg.weaponSelectTime = cg.time;
 
-	for ( i = MAX_WEAPONS-1 ; i > 0 ; i-- ) {
+	for ( i = 15 ; i > 0 ; i-- ) {
 		if ( CG_WeaponSelectable( i ) ) {
 			cg.weaponSelect = i;
 			break;
@@ -1704,6 +1668,9 @@
 ===================================================================================================
 */
 
+extern int cg_numSolidEntities;
+extern centity_t    *cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
+
 /*
 ================
 CG_FireWeapon
@@ -1715,8 +1682,11 @@
 	entityState_t *ent;
 	int				c;
 	weaponInfo_t	*weap;
+    //int addedEntities;
+    //int i;
 
 	ent = &cent->currentState;
+    //ent = &cg_entities[cent->currentState.clientNum].currentState;
 	if ( ent->weapon == WP_NONE ) {
 		return;
 	}
@@ -1726,6 +1696,96 @@
 	}
 	weap = &cg_weapons[ ent->weapon ];
 
+    if (ent->weapon == WP_SHOTGUN)
+        wclients[ent->clientNum].wstats[ent->weapon].atts += 11;
+    else
+        wclients[ent->clientNum].wstats[ent->weapon].atts++;
+    if (ent->weapon == WP_RAILGUN) {
+        trace_t tr;
+        vec3_t muzzle;
+        vec3_t end;
+        vec3_t forward;  //, right, up;
+
+#if 1
+        if ((wolfcam_following  &&  wcg.clientNum == ent->clientNum)  ||
+            (!wolfcam_following  &&  cg.snap->ps.clientNum == ent->clientNum)) {
+            //unsigned int cc;
+            //int xx;
+
+            //trap_Cvar_Set ("timescale", "0.001");
+#if 0
+            for (cc = 0;  cc <  1073741824;  cc++) {
+                if (cc % 2 == 0)
+                    xx++;
+                else
+                    xx--;
+            }
+#endif
+        }
+#endif
+
+        //CG_CalcMuzzlePoint (ent->clientNum, muzzle);
+        //AngleVectors (ent->apos.trBase, forward, right, up);
+
+#if 0
+        if (ent->clientNum == cg.snap->ps.clientNum) {
+            VectorCopy (cg.snap->ps.origin, muzzle);
+            muzzle[2] += cg.snap->ps.viewheight;
+            AngleVectors( cg.snap->ps.viewangles, forward, NULL, NULL );
+            VectorMA( muzzle, 14, forward, muzzle );
+        } else {
+            int anim;
+            VectorCopy (cg_entities[ent->clientNum].currentState.pos.trBase, muzzle);
+            AngleVectors (cg_entities[ent->clientNum].currentState.apos.trBase, forward, NULL, NULL);
+            anim = cg_entities[ent->clientNum].currentState.legsAnim & ~ANIM_TOGGLEBIT;
+            if ( anim == LEGS_WALKCR || anim == LEGS_IDLECR ) {
+                muzzle[2] += CROUCH_VIEWHEIGHT;
+            } else {
+                muzzle[2] += DEFAULT_VIEWHEIGHT;
+            }
+            VectorMA (muzzle, 14, forward, muzzle);
+        }
+#endif
+
+        Wolfcam_CalcMuzzlePoint (ent->clientNum, muzzle, forward, NULL, NULL, qtrue);
+        VectorMA (muzzle, 131072 /*8192 * 1*/, forward, end);
+
+
+        Wolfcam_WeaponTrace (&tr, muzzle, NULL, NULL, end, ent->clientNum, CONTENTS_SOLID|CONTENTS_BODY);
+
+#if 0
+        CG_Printf ("        ^3TRACE ^7%d ^3%d ^7%s\n", cg.time, ent->clientNum,
+                   cgs.clientinfo[ent->clientNum].name);
+#endif
+
+#if 0
+        CG_Printf ("TRACE %d  %s^7  (%f, %f, %f) entnum:%d numSolid:%d\n", 
+                   cg.time,
+                   cgs.clientinfo[ent->clientNum].name, 
+                   muzzle[0], muzzle[1], muzzle[2], 
+                   tr.entityNum,
+                   cg_numSolidEntities
+                   );
+#endif
+        if (tr.entityNum < MAX_CLIENTS) {
+            //CG_Printf ("          ooo     %d [%s^7]  HIT CLIENT %d [%s^7]\n", ent->clientNum, cgs.clientinfo[ent->clientNum].name, tr.entityNum, cgs.clientinfo[tr.entityNum].name);
+        }
+        
+        //if (cg_entities[tr.entityNum].currentState.eType == ET_PLAYER) {
+        if (tr.entityNum < MAX_CLIENTS) {
+#if 0
+            //FIXME wolfcam trace not working
+            wclients[ent->clientNum].wstats[WP_RAILGUN].hits++;
+            //CG_Printf ("          ooo     ^2[[[[[HIT]]]]]^7 for %s^7  ^3on^7  %s\n", cgs.clientinfo[ent->clientNum].name, cgs.clientinfo[tr.entityNum].name);
+            if (wolfcam_following  &&  ent->clientNum == wcg.clientNum) {
+                //trap_S_StartLocalSound (cgs.media.hitSound, CHAN_LOCAL_SOUND);
+                wcg.playHitSound = qtrue;
+            }
+#endif
+        } else {
+            //CG_Printf (" ^3failed for %d\n", ent->clientNum);  //cgs.clientinfo[ent->clientNum].name);
+        }
+    }
 	// mark the entity as muzzle flashing, so when it is added it will
 	// append the flash to the weapon model
 	cent->muzzleFlashTime = cg.time;
@@ -1802,7 +1862,7 @@
 
 	switch ( weapon ) {
 	default:
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_NAILGUN:
 		if( soundType == IMPACTSOUND_FLESH ) {
 			sfx = cgs.media.sfx_nghitflesh;
@@ -1828,7 +1888,7 @@
 		mark = cgs.media.holeMarkShader;
 		radius = 12;
 		break;
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_PROX_LAUNCHER:
 		mod = cgs.media.dishFlashModel;
 		shader = cgs.media.grenadeExplosionShader;
@@ -1898,7 +1958,7 @@
 		radius = 4;
 		break;
 
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_CHAINGUN:
 		mod = cgs.media.bulletFlashModel;
 		if( soundType == IMPACTSOUND_FLESH ) {
@@ -1989,7 +2049,7 @@
 	switch ( weapon ) {
 	case WP_GRENADE_LAUNCHER:
 	case WP_ROCKET_LAUNCHER:
-#ifdef MISSIONPACK
+#if 1  //def MPACK
 	case WP_NAILGUN:
 	case WP_CHAINGUN:
 	case WP_PROX_LAUNCHER:
@@ -2018,8 +2078,21 @@
 */
 static void CG_ShotgunPellet( vec3_t start, vec3_t end, int skipNum ) {
 	trace_t		tr;
+    trace_t     wtr;
 	int sourceContentType, destContentType;
 
+    Wolfcam_WeaponTrace (&wtr, start, NULL, NULL, end, skipNum, CONTENTS_SOLID|CONTENTS_BODY);
+    if (wtr.entityNum < MAX_CLIENTS  &&  cg_entities[wtr.entityNum].currentState.eType != ET_PLAYER) {
+        //CG_Printf ("          ^2SHOTGUN: ^7<MAX_CLIENTS && != ET_PLAYER  %d -> %d\n", skipNum, wtr.entityNum);
+    }
+	if ( cg_entities[wtr.entityNum].currentState.eType == ET_PLAYER ) {
+        wclients[skipNum].wstats[WP_SHOTGUN].hits++;
+        if (wolfcam_following  &&  skipNum == wcg.clientNum) {
+            //trap_S_StartLocalSound (cgs.media.hitSound, CHAN_LOCAL_SOUND);
+            wcg.playHitSound = qtrue;
+        }
+    }
+
 	CG_Trace( &tr, start, NULL, NULL, end, skipNum, MASK_SHOT );
 
 	sourceContentType = trap_CM_PointContents( start, 0 );
diff -Naur cgame.orig/sc.h cgame/sc.h
--- cgame.orig/sc.h	1969-12-31 19:00:00.000000000 -0500
+++ cgame/sc.h	2009-11-29 23:15:05.000000000 -0500
@@ -0,0 +1,13 @@
+#ifndef sc_h_included
+#define sc_h_included
+
+//#include "cg_local.h"  //FIXME broken
+
+//extern vmCvar_t sc_drawBBox;
+
+//void SC_AddBoundingBox (centity_t *cent);
+int SC_ParseEnemyColorsFromStr (const char *s, byte colors[3][4]);
+int SC_Cvar_Get_Int (const char *cvar);
+//void SC_DrawPredictedRail (void);
+
+#endif  // sc_h_included
diff -Naur cgame.orig/sc_misc.c cgame/sc_misc.c
--- cgame.orig/sc_misc.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/sc_misc.c	2009-12-05 17:17:16.000000000 -0500
@@ -0,0 +1,71 @@
+
+#include "cg_local.h"
+
+int SC_ParseEnemyColorsFromStr (const char *s, byte colors[3][4] /* [3][4] */)
+{
+    int i;
+    int j;
+    int sl;
+#define CSIZE (4 * 3)
+    //int wsm[CSIZE];  // end of white space markers
+    int wp;
+    int r, c;
+    qboolean inWhiteSpace;
+
+    for (i = 0;  i < 3;  i++) {
+        for (j = 0;  j < 4;  j++) {
+            colors[i][j] = 255;
+        }
+    }
+
+    if (!s)
+        return -1;
+
+    sl = strlen(s);
+
+    inWhiteSpace = qtrue;
+    r = c = 0;
+    for (wp = 0, i = 0;  i < sl;  i++) {
+
+        if (s[i] != ' '  &&  (s[i] < '0'  ||  s[i] > '9')) {
+            CG_Printf("invalid enemy colors string\n");
+            return -1;
+        }
+        if (inWhiteSpace) {
+            if (s[i] != ' ') {
+                //wsm[wp] = i;
+                //wp++;
+                //if (wp >= CSIZE)
+                //    goto done;
+                inWhiteSpace = qfalse;
+                //CG_Printf("%d:  %d\n", i, atoi(s + i));
+                colors[r][c] = atoi(s + i);
+                //CG_Printf("[%d][%d]:  %d\n", r, c, colors[r][c]);
+                c++;
+                if (c == 3) {
+                    c = 0;
+                    r++;
+                }
+            }
+        } else {
+            if (s[i] == ' ') {
+                inWhiteSpace = qtrue;
+            }
+        }
+    }
+
+// done:
+
+    return 0;
+#undef CSIZE
+}
+
+int SC_Cvar_Get_Int (const char *cvar)
+{
+    char buff[MAX_STRING_CHARS];
+
+    memset(buff, 0, sizeof(buff));
+    trap_Cvar_VariableStringBuffer(cvar, buff, sizeof(buff));
+
+    return atoi(buff);
+}
diff -Naur cgame.orig/wolfcam_consolecmds.c cgame/wolfcam_consolecmds.c
--- cgame.orig/wolfcam_consolecmds.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_consolecmds.c	2007-09-03 14:46:17.000000000 -0400
@@ -0,0 +1,405 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+// from "enemy territory"
+int BG_cleanName( const char *pszIn, char *pszOut, unsigned int dwMaxLength, qboolean fCRLF )
+{
+    const char *pInCopy = pszIn;
+    const char *pszOutStart = pszOut;
+
+    while( *pInCopy && ( pszOut - pszOutStart < dwMaxLength - 1 ) ) {
+        if( *pInCopy == '^' )
+            pInCopy += ((pInCopy[1] == 0) ? 1 : 2);
+        else if( (*pInCopy < 32 && (!fCRLF || *pInCopy != '\n')) || (*pInCopy > 126))
+            pInCopy++;
+        else
+            *pszOut++ = *pInCopy++;
+    }
+
+    *pszOut = 0;
+    return( pszOut - pszOutStart );
+}
+
+
+/*
+===============
+Wolfcam_Players_f
+
+print some info about players
+===============
+*/
+void Wolfcam_Players_f (void)
+{
+    int i;
+    clientInfo_t *ci;
+    char color;
+
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        ci = &cgs.clientinfo[i];
+        if (!ci->infoValid)
+            continue;
+        switch (ci->team) {
+        case TEAM_AXIS:
+            color = '1';
+            break;
+        case TEAM_ALLIES:
+            color = '4';
+            break;
+        case TEAM_SPECTATOR:
+            color = '3';
+            break;
+        case TEAM_FREE:
+            color = '7';
+            break;
+        default:
+            color = '6';
+        }
+        Com_Printf ("^%c X^7  %02d: %s\n", color, i, ci->name);
+    }
+}
+
+/*
+===============
+Wolfcam_Playersw_f
+
+print some info about players
+===============
+*/
+void Wolfcam_Playersw_f (void)
+{
+    int i;
+    clientInfo_t *ci;
+    char color;
+    char name[MAX_QPATH];
+
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        ci = &cgs.clientinfo[i];
+        if (!ci->infoValid)
+            continue;
+        switch (ci->team) {
+        case TEAM_AXIS:
+            color = '1';
+            break;
+        case TEAM_ALLIES:
+            color = '4';
+            break;
+        case TEAM_SPECTATOR:
+            color = '3';
+            break;
+        case TEAM_FREE:
+            color = '7';
+            break;
+        default:
+            color = '6';
+        }
+        //Q_strncpyz (name, ci->name, sizeof(name));
+        //Q_CleanStr (name);
+        BG_cleanName (ci->name, name, sizeof(name), qfalse);
+        Com_Printf ("^%c X^7  %02d: %s\n", color, i, name);
+    }
+}
+
+void Wolfcam_Follow_f (void)
+{
+    int clientNum;
+    char name[MAX_QPATH];
+
+    if (trap_Argc() < 2) {
+        Com_Printf ("currently following [%d]  ", wcg.selectedClientNum);
+        if (wcg.selectedClientNum == -1)
+            Com_Printf ("^3<demo pov>\n");
+        else {
+            //Com_Printf ("%s\n", cgs.clientinfo[wcg.selectedClientNum].name);
+            //Q_strncpyz (name, cgs.clientinfo[wcg.selectedClientNum].name, sizeof(name));
+            //Q_CleanStr (name);
+            BG_cleanName (cgs.clientinfo[wcg.selectedClientNum].name, name, sizeof(name), qfalse);
+            Com_Printf ("%s\n", name);
+        }
+        Com_Printf ("^7use 'follow -1' to return to demo taker's pov\n");
+        return;
+    }
+
+    clientNum = atoi(CG_Argv(1));
+    if (clientNum > MAX_CLIENTS  ||  clientNum < -1) {
+        Com_Printf ("bad client number\n");
+        return;
+    }
+    if (clientNum == -1) {
+        wcg.selectedClientNum = -1;
+        wcg.clientNum = -1;
+        cg.renderingThirdPerson = 0;
+        wolfcam_following = qfalse;
+        trap_Cvar_Set ("cg_thirdPerson", "0");  //FIXME wolfcam
+        return;
+    }
+    if (!cgs.clientinfo[clientNum].infoValid) {
+        Com_Printf ("invalid client\n");
+        return;
+    }
+    
+    wcg.selectedClientNum = clientNum;
+    wcg.clientNum = clientNum;
+    wolfcam_following = qtrue;
+
+    //memset (&wolfcam_esPrev, 0, sizeof(entityState_t));  //FIXME wolfcam per snap for all clients, if invalid use same snap
+}
+
+
+void Wolfcam_Server_Info_f (void)
+{
+    const char *info;
+
+    info = CG_ConfigString( CS_SERVERINFO );
+
+    CG_Printf ("^4server config string: ^2%s\n", info);
+}
+
+static void print_ind_weap_stats (wweaponStats_t *w)
+{
+    //CG_Printf (" %d %d:        %d/%d   ", w->kills, w->deaths, w->hits, w->atts);
+    if (w->kills < 1000)
+        CG_Printf (" ");
+    if (w->kills < 100)
+        CG_Printf (" ");
+    if (w->kills < 10)
+        CG_Printf (" ");
+    CG_Printf ("%d", w->kills);
+
+    if (w->deaths < 1000)
+        CG_Printf (" ");
+    if (w->deaths < 100)
+        CG_Printf (" ");
+    if (w->deaths < 10)
+        CG_Printf (" ");
+    CG_Printf ("%d", w->deaths);
+
+    CG_Printf (":       ");
+
+    if (w->hits < 10000)
+        CG_Printf (" ");
+    if (w->hits < 1000)
+        CG_Printf (" ");
+    if (w->hits < 100)
+        CG_Printf (" ");
+    if (w->hits < 10)
+        CG_Printf (" ");
+    CG_Printf ("%d / ", w->hits);
+
+    if (w->atts < 10000)
+        CG_Printf (" ");
+    if (w->atts < 1000)
+        CG_Printf (" ");
+    if (w->atts < 100)
+        CG_Printf (" ");
+    if (w->atts < 10)
+        CG_Printf (" ");
+    CG_Printf ("%d", w->atts);
+    
+    CG_Printf ("    ");
+
+    if (w->atts  &&  w->hits)
+        CG_Printf ("%0.2f", (float)(w->hits) / (float)(w->atts));
+    else {
+        //CG_Printf ("0.00");
+    }
+
+    CG_Printf ("\n");
+}
+
+static void wolfcam_print_weapon_stats (int clientNum, qboolean oldclient)
+{
+    char *name;
+    int kills;
+    int deaths;
+    int suicides;
+    int warp;
+    int nowarp;
+    int warpaccum;
+	int noCommandCount;
+	int validCount;
+	int invalidCount;
+	int serverPingAccum;
+	int serverPingSamples;
+	int snapshotPingAccum;
+	int snapshotPingSamples;
+	
+    wweaponStats_t *w;
+    wweaponStats_t *ws;  //[WP_NUM_WEAPONS];
+   
+    if (oldclient) {
+        woldclient_t *wc = &woldclients[clientNum];
+
+        name = woldclients[clientNum].clientinfo.name;
+        kills = woldclients[clientNum].kills;
+        deaths = woldclients[clientNum].deaths;
+        suicides = woldclients[clientNum].suicides;
+        warp = wc->warp;
+        nowarp = wc->nowarp;
+        warpaccum = wc->warpaccum;
+		validCount = wc->validCount;
+		invalidCount = wc->invalidCount;
+		serverPingAccum = wc->serverPingAccum;
+		serverPingSamples = wc->serverPingSamples;
+		snapshotPingAccum = wc->snapshotPingAccum;
+		snapshotPingSamples = wc->snapshotPingSamples;
+		noCommandCount = wc->noCommandCount;
+
+        ws = woldclients[clientNum].wstats;
+    } else {
+        wclient_t *wc = &wclients[clientNum];
+
+        name = cgs.clientinfo[clientNum].name;
+        kills = wclients[clientNum].kills;
+        deaths = wclients[clientNum].deaths;
+        suicides = wclients[clientNum].suicides;
+        warp = wc->warp;
+        nowarp = wc->nowarp;
+        warpaccum = wc->warpaccum;
+		validCount = wc->validCount;
+		invalidCount = wc->invalidCount;
+		serverPingAccum = wc->serverPingAccum;
+		serverPingSamples = wc->serverPingSamples;
+		snapshotPingAccum = wc->snapshotPingAccum;
+		snapshotPingSamples = wc->snapshotPingSamples;
+		noCommandCount = wc->noCommandCount;
+
+        ws = wclients[clientNum].wstats;
+    }
+
+	CG_Printf("^1-------------------------------------------------------\n");
+    CG_Printf ("^7Stats for %s^3:\n", name);
+
+    //    CG_Printf ("^7kills: ^3%d  ^7deaths: ^3%d  ^7suicides: ^3%d\n", wclients[clientNum].kills, wclients[clientNum].deaths, wclients[clientNum].suicides);
+    CG_Printf("    ^7kills: %d  ^7deaths: %d  ^7suicides: %d\n", kills, deaths, suicides);
+	CG_Printf("    in %d frames out of %d   ^3%0.2f\n", validCount, invalidCount + validCount, (invalidCount + validCount) > 0 ? (float)validCount / (float)(invalidCount + validCount) : -1);
+    CG_Printf("    noCommand: (%d / %d)  warp: %d nowarp: %d ", noCommandCount, snapshotPingSamples, warp, nowarp);
+
+    if ((nowarp) > 0)
+        CG_Printf (" %f", (float)warp / (float)(nowarp));
+    else
+        CG_Printf ("         ");
+    if (warp > 0)
+        CG_Printf ("  %d\n", warpaccum / warp);
+    else
+        CG_Printf ("\n");
+
+    CG_Printf("    serverPing:    ^3%d    ^7%d\n", serverPingSamples ? serverPingAccum / serverPingSamples : -1, serverPingSamples);
+	CG_Printf("    snapshotPing:  ^3%d    ^7%d\n", snapshotPingSamples ? snapshotPingAccum / snapshotPingSamples / 2 : -1, snapshotPingSamples);
+
+    w = &ws[WP_GAUNTLET];
+    //w = &wclients[clientNum].wstats[WP_GAUNTLET];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2gauntlet     ");
+        print_ind_weap_stats (w);
+    }
+
+    //w = &wclients[clientNum].wstats[WP_LIGHTNING];
+    w = &ws[WP_LIGHTNING];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2lightning gun");
+        print_ind_weap_stats (w);
+    }
+
+    //w = &wclients[clientNum].wstats[WP_MACHINEGUN];
+    w = &ws[WP_MACHINEGUN];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2machinegun   ");
+        print_ind_weap_stats (w);
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_SHOTGUN];
+    {
+        wweaponStats_t wtmp;
+        
+    w = &ws[WP_SHOTGUN];
+    memcpy (&wtmp, w, sizeof (wweaponStats_t));
+    // shotgun kludge
+    //wtmp.hits /= DEFAULT_SHOTGUN_COUNT;
+    if (wtmp.kills  ||  wtmp.deaths  ||  wtmp.atts) {
+        CG_Printf ("  ^2shotgun      ");
+        print_ind_weap_stats (&wtmp);
+    }
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_ROCKET_LAUNCHER];
+    w = &ws[WP_ROCKET_LAUNCHER];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2rocket       ");
+        print_ind_weap_stats (w);
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_GRENADE_LAUNCHER];
+    w = &ws[WP_GRENADE_LAUNCHER];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2grenade      ");
+        print_ind_weap_stats (w);
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_PLASMAGUN];
+    w = &ws[WP_PLASMAGUN];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2plasma gun   ");
+        print_ind_weap_stats (w);
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_RAILGUN];
+    w = &ws[WP_RAILGUN];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2rail gun     ");
+        print_ind_weap_stats (w);
+    }
+
+    //    w = &wclients[clientNum].wstats[WP_BFG];
+    w = &ws[WP_BFG];
+    if (w->kills  ||  w->deaths  ||  w->atts) {
+        CG_Printf ("  ^2bfg          ");
+        print_ind_weap_stats (w);
+    }
+
+}
+
+void Wolfcam_Weapon_Stats_f (void)
+{
+    
+    int clientNum;
+
+    if (trap_Argc() < 2) {
+        if (wolfcam_following)
+            clientNum = wcg.clientNum;
+        else
+            clientNum = cg.clientNum;
+    } else {
+        clientNum = atoi(CG_Argv(1));
+    }
+
+    if (clientNum == -1)
+        clientNum = cg.clientNum;
+
+    if (clientNum < 0  ||  clientNum > MAX_CLIENTS) {
+        CG_Printf ("invalid client number\n");
+        return;
+    }
+
+    wolfcam_print_weapon_stats (clientNum, qfalse);
+}
+
+void Wolfcam_Weapon_Statsall_f (void)
+{
+    int i;
+
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        if (cgs.clientinfo[i].infoValid) {
+            wolfcam_print_weapon_stats (i, qfalse);
+            CG_Printf ("\n");
+        }
+    }
+
+    if (wnumOldClients) {
+        CG_Printf ("disconnected clients:\n\n");
+        for (i = 0;  i < wnumOldClients;  i++) {
+            wolfcam_print_weapon_stats (i, qtrue);
+            CG_Printf ("\n");
+        }
+    }
+}
+
diff -Naur cgame.orig/wolfcam_ents.c cgame/wolfcam_ents.c
--- cgame.orig/wolfcam_ents.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_ents.c	2009-11-30 20:33:16.000000000 -0500
@@ -0,0 +1,185 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+void Wolfcam_MarkValidEntities (void)
+{
+	centity_t *cent;
+	int num;
+    int i;
+
+#if 0
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        if (cgs.clientinfo[i].infoValid  &&  cg_entities[i].currentValid) {
+            wclients[i].currentValid = qtrue;
+            wclients[i].validTime = cg.time;
+        } else {
+            wclients[i].currentValid = qfalse;
+            wclients[i].invalidTime = cg.time;
+        }
+    }
+#endif
+
+	for (i = 0;  i < MAX_CLIENTS;  i++) {
+        wclients[i].currentValid = qfalse;
+    }
+
+    for (num = 0;  num < cg.snap->numEntities;  num++) {
+        cent = &cg_entities[cg.snap->entities[num].number];
+        //FIXME ET_CORPSE ?
+
+        //if ((cent->currentState.eType == ET_PLAYER  ||  cent->currentState.eType == ET_CORPSE)  &&
+        //     cgs.clientinfo[cent->currentState.clientNum].infoValid) {
+        if (cent->currentState.eType == ET_PLAYER) {
+            wclients[cent->currentState.clientNum].currentValid = qtrue;
+            wclients[cent->currentState.clientNum].validTime = cg.time;
+        }
+    }
+
+    wclients[cg.snap->ps.clientNum].currentValid = qtrue;
+    wclients[cg.snap->ps.clientNum].validTime = cg.time;
+}
+
+qboolean Wolfcam_InterpolateEntityPosition (centity_t *cent) 
+{
+	vec3_t		current, next;
+	float		f;
+	qboolean useCurrent = qfalse;
+	entityState_t *esPrev, *esNext;
+	int i;
+	snapshot_t *snapPrev, *snapNext;
+	qboolean presentInSnapPrev, presentInSnapNext;
+	int trPrevOrig, trNextOrig;
+	int delta;
+	qboolean isBot;
+	int s1, s2;
+
+	// it would be an internal error to find an entity that interpolates without
+	// a snapshot ahead of the current one
+	if ( cg.nextSnap == NULL ) {
+		CG_Error( "CG_InterpoateEntityPosition: cg.nextSnap == NULL" );
+		return qtrue;
+	}
+
+	f = cg.frameInterpolation;
+
+	if (!cg.demoPlayback  ||  wcg.curSnapshotNumber < 3  ||  cent->currentState.number == cg.snap->ps.clientNum  ||  useCurrent  ||  wolfcam_following  ||  wolfcam_useOriginalInterpolation.integer) {
+		return qfalse;  // use original CG_InterpolateEntityPosition()
+	}
+
+	//return qfalse;
+	//CG_Printf ("wolfcam interp\n");
+
+	////////////////////////////////////////////////
+	f = cg.frameInterpolation;
+
+	// this will linearize a sine or parabolic curve, but it is important
+	// to not extrapolate player positions if more recent data is available
+	BG_EvaluateTrajectory( &cent->currentState.pos, cg.snap->serverTime, current );
+	BG_EvaluateTrajectory( &cent->nextState.pos, cg.nextSnap->serverTime, next );
+
+	cent->lerpOrigin[0] = current[0] + f * ( next[0] - current[0] );
+	cent->lerpOrigin[1] = current[1] + f * ( next[1] - current[1] );
+	cent->lerpOrigin[2] = current[2] + f * ( next[2] - current[2] );
+
+	BG_EvaluateTrajectory( &cent->currentState.apos, cg.snap->serverTime, current );
+	BG_EvaluateTrajectory( &cent->nextState.apos, cg.nextSnap->serverTime, next );
+
+	cent->lerpAngles[0] = LerpAngle( current[0], next[0], f );
+	cent->lerpAngles[1] = LerpAngle( current[1], next[1], f );
+	cent->lerpAngles[2] = LerpAngle( current[2], next[2], f );
+
+	Wolfcam_AddBoundingBox (cent);
+
+	if (cgs.clientinfo[cent->currentState.clientNum].botSkill > 0)
+		isBot = qtrue;
+	else
+		isBot = qfalse;
+
+	esPrev = NULL;
+	esNext = NULL;
+	presentInSnapPrev = qfalse;
+	presentInSnapNext = qfalse;
+
+	// wcg.curSnapshotNumber - 1  == currentSnap
+	// wcg.curSnapshotNumber - 2  == prevSnap
+	//snapPrev = &wcg.snaps[(wcg.curSnapshotNumber - 3) & MAX_SNAPSHOT_MASK];
+	//snapNext = &wcg.snaps[(wcg.curSnapshotNumber - 2) & MAX_SNAPSHOT_MASK];
+
+	if (wcg.curSnapshotNumber < 3)
+		return qfalse;
+
+	if (isBot) {
+		s1 = 2;
+		s2 = 1;
+	} else {
+		s1 = 3;
+		s2 = 2;
+	}
+
+	//return qfalse;
+	snapPrev = &wcg.snaps[(wcg.curSnapshotNumber - s1) & MAX_SNAPSHOT_MASK];
+	snapNext = &wcg.snaps[(wcg.curSnapshotNumber - s2) & MAX_SNAPSHOT_MASK];
+
+	// the ones that match up are snapPrev == 2, snapNext == 1
+	for (i = 0;  i < snapPrev->numEntities;  i++) {
+		esPrev = &snapPrev->entities[i];
+		if (esPrev->number == cent->currentState.number) {
+			presentInSnapPrev = qtrue;
+			break;
+		}
+	}
+
+	for (i = 0;  i < snapNext->numEntities;  i++) {
+		esNext = &snapNext->entities[i];
+		if (esNext->number == cent->currentState.number) {
+			presentInSnapNext = qtrue;
+			break;
+		}
+	}
+
+	if (!presentInSnapPrev  ||  !presentInSnapNext)
+		return qfalse;  // use original CG_InterpolateEntityPosition()
+
+	//BG_EvaluateTrajectory( &esPrev->pos, snapPrev->serverTime + 25, current );
+	//BG_EvaluateTrajectory( &esNext->pos, snapNext->serverTime + 25, next );
+
+	trPrevOrig = esPrev->pos.trType;
+	trNextOrig = esNext->pos.trType;
+
+	//esPrev->pos.trType = TR_LINEAR;
+	//esNext->pos.trType = TR_LINEAR;
+
+	//	CG_Printf ("f: %f\n", f);
+	//f += 15.0;
+	//CG_Printf ("f: %f\n", f);
+
+	delta = (cg.nextSnap->serverTime - cg.snap->serverTime);
+	if (delta == 0)
+		f = 0;
+	else
+		f = (float)( cg.time - (delta / 2) - cg.snap->serverTime ) / delta;
+
+#define DV 0
+	BG_EvaluateTrajectory( &esPrev->pos, snapPrev->serverTime + DV, current );
+	BG_EvaluateTrajectory( &esNext->pos, snapNext->serverTime + DV, next );
+
+	cent->lerpOrigin[0] = current[0] + f * ( next[0] - current[0] );
+	cent->lerpOrigin[1] = current[1] + f * ( next[1] - current[1] );
+	cent->lerpOrigin[2] = current[2] + f * ( next[2] - current[2] );
+
+	BG_EvaluateTrajectory( &esPrev->apos, snapPrev->serverTime + DV, current );
+	BG_EvaluateTrajectory( &esNext->apos, snapNext->serverTime + DV, next );
+
+#undef DV
+	cent->lerpAngles[0] = LerpAngle( current[0], next[0], f );
+	cent->lerpAngles[1] = LerpAngle( current[1], next[1], f );
+	cent->lerpAngles[2] = LerpAngle( current[2], next[2], f );
+
+	esPrev->pos.trType = trPrevOrig;
+	esNext->pos.trType = trNextOrig;
+
+	//CG_Printf ("..done\n");
+
+	return qtrue;
+}
+
diff -Naur cgame.orig/wolfcam_event.c cgame/wolfcam_event.c
--- cgame.orig/wolfcam_event.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_event.c	2009-12-06 00:55:55.000000000 -0500
@@ -0,0 +1,361 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+static char *weapNames[] = {
+    "WP_NONE",
+    "WP_GAUNTLET",
+    "WP_MACHINEGUN",
+    "WP_SHOTGUN",
+    "WP_GRENADE_LAUNCHER",
+    "WP_ROCKET_LAUNCHER",
+    "WP_LIGHTNING",
+    "WP_RAILGUN",
+    "WP_PLASMAGUN",
+    "WP_BFG",
+    "WP_GRAPPLING_HOOK"
+};
+
+#if 0
+static qboolean viewangles_have_changed (int clientNum, int snapshots) 
+{
+    int i;
+    qboolean angleChange;
+    vec3_t angs;
+
+    //FIXME what if clientNum and/or cg.snap->ps.clietNum have changed?
+    if (wcg.curSnapshotNumber < snapshots)
+        return qfalse;
+
+    if (clientNum == cg.snap->ps.clientNum) {
+        VectorCopy (cg.snap->ps.viewangles, angs);
+    } else {
+        VectorCopy (cg_entities[clientNum].currentState.apos.trBase, angs);
+    }
+
+    angleChange = qfalse;
+
+    for (i = 1;  i <= snapshots;  i++) {
+        //vec3_t a;
+        snapshot_t *s;
+        int num;
+        qboolean foundEnt;
+
+        s = &wcg.snaps[(wcg.curSnapshotNumber - i) & MAX_SNAPSHOT_MASK];
+
+        if (s->ps.clientNum == clientNum) {
+            if (s->ps.viewangles[0] != angs[0]  ||  s->ps.viewangles[1] != angs[1]) {
+                CG_Printf ("viewangles changed: -%d (%d)  %s  (%f %f)  (%f %f)\n",
+                           i,
+                           clientNum, 
+                           cgs.clientinfo[clientNum].name, 
+                           s->ps.viewangles[0],
+                           s->ps.viewangles[1],
+                           angs[0], angs[1]);
+                return qtrue;
+            }
+            continue;
+        }
+
+        foundEnt = qfalse;
+        for (num = 0;  num < s->numEntities;  num++) {
+            entityState_t *es; 
+            
+            es = &s->entities[num];
+            if (es->number == clientNum) {
+                foundEnt = qtrue;
+                // do check
+                //CG_Printf ("found client\n");
+                if (es->apos.trBase[0] != angs[0]  ||  es->apos.trBase[1] != angs[1]) {
+                    CG_Printf ("viewangles changed: -%d  (%d)  %s  (%f %f)  (%f %f)\n", 
+                               i,
+                               clientNum, 
+                               cgs.clientinfo[clientNum].name, 
+                               es->apos.trBase[0], es->apos.trBase[1], 
+                               angs[0], angs[1]);
+                    return qtrue;
+                }
+                break;
+            }
+        }
+        if (!foundEnt) {
+            CG_Printf ("ent %d not even found\n", clientNum);
+            return qfalse;
+        }
+    }
+
+    return angleChange;
+}
+#endif
+
+        
+/* returns -1 if no possible target found */
+//FIXME duck, prone, and whatever shit
+static int find_best_target (int attackerClientNum, qboolean useLerp, vec_t *distance, vec3_t offsets)
+{
+    //clientInfo_t *tci;
+    centity_t *ac;
+    centity_t *tc;
+    entityState_t *aes;
+    entityState_t *tes;
+    vec3_t avec;
+    vec3_t tvec;
+    vec3_t aangs;
+    //vec3_t oldAangs;
+    //vec3_t tangs;
+    int possibleTarget;  // if -1, no targets found
+    vec3_t dirVec;
+    vec3_t dirAngs;
+    vec3_t yxerr;
+    vec_t dist = 0.0f;
+    int i;
+    int anim;
+    
+    possibleTarget = -1;
+
+    ac = &cg_entities[attackerClientNum];
+    aes = &ac->currentState;
+
+    if ((!cgs.clientinfo[attackerClientNum].infoValid  ||  !ac->currentValid)  &&  attackerClientNum != cg.snap->ps.clientNum)
+        return -1;
+
+    if (useLerp) {
+        VectorCopy (ac->lerpOrigin, avec);
+        VectorCopy (ac->lerpAngles, aangs);
+    } else {
+        VectorCopy (aes->pos.trBase, avec);
+        VectorCopy (aes->apos.trBase, aangs);
+    }
+
+    anim = aes->legsAnim & ~ANIM_TOGGLEBIT;
+    if (anim == LEGS_WALKCR  ||  anim == LEGS_IDLECR)
+        avec[2] += CROUCH_VIEWHEIGHT;
+    else
+        avec[2] += DEFAULT_VIEWHEIGHT;  //FIXME crouching or +8 ?
+
+    possibleTarget = -1;
+
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        //tci = &cgs.clientinfo[i];
+
+        if ((!cgs.clientinfo[i].infoValid  ||  !cg_entities[i].currentValid)  &&  i != cg.snap->ps.clientNum)
+            continue;
+        //FIXME w team stuff
+        if (cgs.clientinfo[i].team != TEAM_FREE)
+            continue;
+
+        if (i == attackerClientNum)
+            continue;
+
+        tc = &cg_entities[i];
+        tes = &tc->currentState;
+        if (useLerp) {
+            VectorCopy (tc->lerpOrigin, tvec);
+        } else {
+            VectorCopy (tes->pos.trBase, tvec);
+        }
+
+        anim = tes->legsAnim & ~ANIM_TOGGLEBIT;
+        if (anim == LEGS_WALKCR  ||  anim == LEGS_IDLECR)
+            tvec[2] += CROUCH_VIEWHEIGHT;
+        else
+            tvec[2] += DEFAULT_VIEWHEIGHT;
+
+        //        tvec[2] += 8;  //FIXME viewheight?
+
+        VectorSubtract (tvec, avec, dirVec);
+        vectoangles (dirVec, dirAngs);
+       
+        if (possibleTarget == -1) {
+            possibleTarget = i;
+            //AnglesSubtract (aangs, dirAngs, yxerr);
+            AnglesSubtract (dirAngs, aangs, yxerr);
+            dist = VectorLength (dirVec);
+        } else {
+            vec3_t tmpyxerr;
+
+            //AnglesSubtract (aangs, dirAngs, tmpyxerr);
+            AnglesSubtract (dirAngs, aangs, tmpyxerr);
+            if (VectorLength(tmpyxerr) < VectorLength(yxerr)) {
+                // better target found
+                possibleTarget = i;
+                VectorCopy (tmpyxerr, yxerr);
+                dist = VectorLength (dirVec);
+            }
+        }
+    }
+
+    if (possibleTarget > -1  &&  !(cg_entities[possibleTarget].currentState.eFlags & EF_DEAD)) {
+        VectorCopy (yxerr, offsets);
+        //        *distance = VectorLength (dirVec);
+        *distance = dist;
+    } else
+        possibleTarget = -1;
+
+    return possibleTarget;
+}
+
+void wolfcam_log_event (centity_t *cent, vec3_t position)
+{
+    entityState_t *es;
+    int event;
+    int clientNum;
+    clientInfo_t *ci;
+    char *s;
+    vec_t distance;
+
+    es = &cent->currentState;
+    event = es->event & ~EV_EVENT_BITS;
+
+    clientNum = es->clientNum;
+    if (clientNum < 0  ||  clientNum >= MAX_CLIENTS)
+        return;
+
+    ci = &cgs.clientinfo[clientNum];
+
+    //FIXME shotgun
+    switch (event) {
+    case EV_OBITUARY:
+        wclients[es->otherEntityNum].deathTime = cg.time;
+        //        CG_Printf ("%s^7  deathTime:%d\n", cgs.clientinfo[es->otherEntityNum].name, cg.time);
+        break;
+    case EV_FIRE_WEAPON: {
+        int target;
+        vec3_t offsets;
+        
+        //s = va("EV_FIRE_WEAPON: %d %d %d %s %s
+        s = va("EV_FIRE_WEAPON\n");
+        trap_FS_Write (s, strlen(s), wc_logfile);
+        s = va("%d %d %s\n", clientNum, es->weapon, weapNames[es->weapon]);
+        trap_FS_Write (s, strlen(s), wc_logfile);
+        s = va("%s\n", cgs.clientinfo[clientNum].name);
+        trap_FS_Write (s, strlen(s), wc_logfile);
+
+        target = find_best_target (clientNum, qfalse, &distance, offsets);
+        if (target > -1) {  //  &&  viewangles_have_changed(clientNum, 1)) {
+            s = va("%d\n", target);
+#if 0
+            s = va("%d %f %f %f\n", target, cg_entities[target].currentState.pos.trBase[0],
+                   cg_entities[target].currentState.pos.trBase[1],
+                   cg_entities[target].currentState.pos.trBase[2]);
+#endif
+            trap_FS_Write (s, strlen(s), wc_logfile);
+            s = va("%s\n", cgs.clientinfo[target].name);
+            trap_FS_Write (s, strlen(s), wc_logfile);
+            s = va("%f %f %f\n", offsets[YAW], offsets[PITCH], distance);
+            trap_FS_Write (s, strlen(s), wc_logfile);
+
+#if 0
+            // testing
+            s = va("%f %f %f    %f %f %f  %s\n", 
+                   cg_entities[clientNum].currentState.pos.trBase[0],
+                   cg_entities[clientNum].currentState.pos.trBase[1],
+                   cg_entities[clientNum].currentState.pos.trBase[2],
+                   cg_entities[clientNum].currentState.apos.trBase[0],
+                   cg_entities[clientNum].currentState.apos.trBase[1],
+                   cg_entities[clientNum].currentState.apos.trBase[2],
+                   cgs.clientinfo[clientNum].name);
+            trap_FS_Write (s, strlen(s), wc_logfile);
+
+            s = va("%f %f %f    %f %f %f  %s\n",
+                   cg_entities[target].currentState.pos.trBase[0],
+                   cg_entities[target].currentState.pos.trBase[1],
+                   cg_entities[target].currentState.pos.trBase[2],
+                   cg_entities[target].currentState.apos.trBase[0],
+                   cg_entities[target].currentState.apos.trBase[1],
+                   cg_entities[target].currentState.apos.trBase[2],
+                   cgs.clientinfo[target].name);
+            trap_FS_Write (s, strlen(s), wc_logfile);
+#endif
+
+        } else {
+            s = va ("-1\n\n0.0 0.0 0.0\n");
+            trap_FS_Write (s, strlen(s), wc_logfile);
+        }
+
+        s = va("---\n");
+        trap_FS_Write (s, strlen(s), wc_logfile);
+        break;
+    }
+    default:
+        break;
+    }
+}
+
+void Wolfcam_LogMissileHit (int weapon, vec3_t origin, vec3_t dir, int entityNum)
+{
+    clientInfo_t *ci;
+    centity_t *cent;
+    entityState_t *es;
+    int i;
+    int possibleClient = -1;
+    vec3_t dirVec;
+    vec3_t dirAngs;
+    vec3_t yxerr;
+    vec3_t tmpyxerr;
+    vec_t dist;
+
+    //CG_Printf ("Wolfcam_LogMissileHit: %d %s    %d %s\n", weapon, weapNames[weapon], entityNum, cgs.clientinfo[entityNum].name);
+
+    //FIXME wolfcam for lightning also exclude by distance
+
+    if (weapon != WP_LIGHTNING) { //  &&  weapon != WP_PLASMAGUN)  //FIXME wolfcam other weapons
+        //return;
+    }
+
+    //CG_Printf ("about to check...\n");
+
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        ci = &cgs.clientinfo[i];
+        cent = &cg_entities[i];
+        es = &cent->currentState;
+
+        if (i == entityNum)
+            continue;
+
+        if (!ci->infoValid)
+            continue;
+        if (!cent->currentValid  &&  cg.snap->ps.clientNum != i)
+            continue;
+        //FIXME wolfcam team stuff
+        if (ci->team != TEAM_FREE)
+            continue;
+        if (es->weapon != weapon)  //FIXME wolfcam only for lightning
+            continue;
+        
+        //FIXME wolfcam viewheights ?
+
+        //CG_Printf ("checking angles for %d  %s\n", i, ci->name);
+
+        VectorSubtract (origin, es->pos.trBase, dirVec);
+        vectoangles (dirVec, dirAngs);
+        
+        if (possibleClient == -1) {
+            possibleClient = i;
+            AnglesSubtract (dirAngs, es->apos.trBase, yxerr);
+            dist = VectorLength (dirVec);
+        } else {
+            AnglesSubtract (dirAngs, es->apos.trBase, tmpyxerr);
+            if (VectorLength(tmpyxerr) < VectorLength(yxerr)) {
+                // better attacker found
+                //CG_Printf ("found better: %d  %s\n", i, cgs.clientinfo[i].name);
+                possibleClient = i;
+                VectorCopy (tmpyxerr, yxerr);
+                dist = VectorLength (dirVec);
+            }
+        }
+    }
+
+    //FIXME wolfcam can be dead for other than lightning
+    if (possibleClient > -1  &&  !(cg_entities[possibleClient].currentState.eFlags & EF_DEAD)) {
+        //CG_Printf ("logging %s hit for %s\n", weapNames[weapon], cgs.clientinfo[possibleClient].name);
+        //wclients[possibleClient].wstats[weapon].hits++;
+        wclients[possibleClient].wstats[weapon].hits++;
+        if (wolfcam_following  &&  wcg.clientNum == possibleClient) {
+            //trap_S_StartLocalSound (cgs.media.hitSound, CHAN_LOCAL_SOUND);
+            wcg.playHitSound = qtrue;
+        }
+        
+    } else {
+        //CG_Printf ("couldn't find attacker for missile\n");
+    }
+}
diff -Naur cgame.orig/wolfcam_info.c cgame/wolfcam_info.c
--- cgame.orig/wolfcam_info.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_info.c	2009-12-05 17:11:35.000000000 -0500
@@ -0,0 +1,34 @@
+#include "cg_local.h"
+#include "../client/keycodes.h"
+#include "wolfcam_local.h"
+
+extern void CG_ScoresUp_f (void);
+extern void CG_ScoresDown_f (void);
+
+// from http://www.quake3world.com/ubb/Forum4/HTML/006208.html by RR2DO2
+// and ET sdk
+
+void Wolfcam_DemoClick (int key, qboolean down)
+{
+    int t;
+
+    t = trap_Milliseconds();
+
+    // Avoid active console keypress issues
+    if (!down  &&  !cgs.fKeyPressed[key])
+        return;
+
+    cgs.fKeyPressed[key] = down;
+
+    switch (key) {
+    case K_TAB:
+        if (down)
+            CG_ScoresDown_f ();
+        else
+            CG_ScoresUp_f ();
+        return;
+    default:
+        //CG_Printf ("key: %d\n", key);
+        break;
+    }
+}
diff -Naur cgame.orig/wolfcam_local.h cgame/wolfcam_local.h
--- cgame.orig/wolfcam_local.h	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_local.h	2009-12-05 18:05:06.000000000 -0500
@@ -0,0 +1,262 @@
+#ifndef wolfcam_h_included
+#define wolfcam_h_included
+
+//#include "cg_local.h"
+
+#define DEBUG_BUFFER_SIZE 4192
+
+#define WOLFCAM_VERSION "0.0.2"
+
+#define WOLFCAM_UNKNOWN 0
+#define WOLFCAM_BASEQ3 1
+//#define WOLFCAM_ETMAIN 1
+//#define WOLFCAM_ETPRO 2
+
+// rtcw
+#define TEAM_AXIS TEAM_RED
+#define TEAM_ALLIES TEAM_BLUE
+
+#define PAIN_EV_TIME 700
+
+#define MAX_SNAPSHOT_BACKUP     256
+#define MAX_SNAPSHOT_MASK       (MAX_SNAPSHOT_BACKUP - 1)
+
+
+//#define GetAmmoTableData(ammoIndex) ((ammotable_t*)(&ammoTable[ammoIndex]))
+
+
+// wolfcam global vars
+typedef struct {
+    int selectedClientNum;  // client selected by user
+    int clientNum;  // client currently following
+
+    vec3_t vieworgDemo;
+    vec3_t refdefViewAnglesDemo;
+
+    //snapshot_t oldSnap;
+    //qboolean oldSnapValid;
+
+    snapshot_t snaps[MAX_SNAPSHOT_BACKUP];
+    int curSnapshotNumber;
+	int missedSnapshots;
+
+    qboolean fastForward;
+    qboolean fastForwarding;
+    char oldTimescale[MAX_CVAR_VALUE_STRING];
+    char oldVolume[MAX_CVAR_VALUE_STRING];
+
+    qboolean playHitSound;
+} wcg_t;
+
+//FIXME wolfcam mg42
+typedef struct {
+    unsigned int atts;
+    unsigned int hits;
+    unsigned int teamHits;
+    unsigned int corpseHits;  // gibbing
+    unsigned int teamCorpseHits;
+    unsigned int headshots;
+    unsigned int kills;
+    unsigned int deaths;
+    unsigned int suicides;
+} wweaponStats_t;
+
+typedef struct {
+    qboolean currentValid;
+	int validCount;  // how many snapshots they are present in
+	int invalidCount;
+
+    int invalidTime;
+    int validTime;
+
+    int health;
+    int healthTime;
+
+    int deathTime;
+
+    int eventHealth;  // guessed from EV_*
+    //int eventHealthTime;
+    int ev_pain_time;  // EV_PAIN
+    int bulletDamagePitch;
+    int bulletDamageYaw;
+
+    int landChange;
+    int landTime;
+
+    int duckChange;
+    int duckTime;
+
+    qboolean zoomedBinoc;
+    int binocZoomTime;
+    int zoomTime;
+    int zoomval;
+
+    int event_fireWeaponTime;
+    int event_akimboFire;
+    int event_overheatTime;
+    int event_reloadTime;
+    int event_weaponSwitchTime;
+    int event_newWeapon;
+    int event_oldWeapon;
+    
+    int grenadeDynoTime;
+    int grenadeDynoLastTime;
+
+    int muzzleFlashTime;
+    int bulletDamageTime;  //FIXME wolfcam tmp garbage
+
+    entityState_t oldState;
+
+    //FIXME wolfcam the following is messed up
+    entityState_t esPrev;
+    int prevTime;
+
+    int weapAnim;
+    int weapAnimPrev;
+    int weapAnimTimer;
+
+    float xyspeed;
+    float bobfracsin;
+    int bobcycle;
+    int psbobCycle;
+    float lastvalidBobfracsin;
+    int lastvalidBobcycle;
+
+    qboolean crosshairClientNoShoot;
+    int oldSolid;
+
+    // blend blobs
+    //viewDamage_t viewDamage[MAX_VIEWDAMAGE];
+    float damageTime;  // last time any kind of damage was recieved
+    int damageIndex;  // slot that was filled in
+    float damageX, damageY, damageValue;
+
+    float v_dmg_time;
+    float v_dmg_pitch;
+    float v_dmg_roll;
+
+    int kills;
+    int deaths;
+    int suicides;
+
+    //FIXME wolfcam ammo
+
+    int warp;
+    int nowarp;
+    int warpaccum;
+	int noCommandCount;
+
+	int serverPingAccum;
+	int serverPingSamples;
+	int snapshotPingAccum;
+	int snapshotPingSamples;
+
+    wweaponStats_t wstats[WP_NUM_WEAPONS];
+    
+} wclient_t;
+
+typedef struct {
+    qboolean valid;
+	int validCount;  // how many snapshots they are present in
+	int invalidCount;
+
+    int clientNum;
+    clientInfo_t clientinfo;
+
+
+    int kills;
+    int deaths;
+    int suicides;
+
+    int warp;
+    int nowarp;
+    int warpaccum;
+	int noCommandCount;
+
+	int serverPingAccum;
+	int serverPingSamples;
+	int snapshotPingAccum;
+	int snapshotPingSamples;
+
+    wweaponStats_t wstats[WP_NUM_WEAPONS];
+
+} woldclient_t;
+
+extern int wolfcam_gameVersion;
+
+extern char globalDebugString[DEBUG_BUFFER_SIZE];
+extern int wolfcam_initialSnapshotNumber;
+
+extern qboolean wolfcam_following;
+
+extern wcg_t wcg;
+extern wclient_t wclients[MAX_CLIENTS];
+extern woldclient_t woldclients[MAX_CLIENTS];  // clients that have disconnected
+extern int wnumOldClients;
+extern fileHandle_t wc_logfile;
+
+extern vmCvar_t wolfcam_debugErrors;
+extern vmCvar_t wolfcam_debugDrawGun;
+extern vmCvar_t wolfcam_fakelag;
+extern vmCvar_t wolfcam_fast_forward_timescale;
+extern vmCvar_t wolfcam_fast_forward_invalid_time;
+extern vmCvar_t wolfcam_execIntermission;
+extern vmCvar_t wolfcam_execShutdown;
+extern vmCvar_t wolfcam_wh;
+extern vmCvar_t wolfcam_fixedViewAngles;
+extern vmCvar_t wolfcam_useOriginalInterpolation;
+extern vmCvar_t wolfcam_drawBBox;
+
+void Wolfcam_Players_f (void);
+void Wolfcam_Playersw_f (void);
+
+
+void Wolfcam_Follow_f (void);
+void Wolfcam_Server_Info_f (void);
+
+#if 1
+void Wolfcam_Weapon_Stats_f (void);
+void Wolfcam_Weapon_Statsall_f (void);
+
+void Wolfcam_DemoClick (int key, qboolean down);
+
+void Wolfcam_OwnerDraw (float x, float y, float w, float h, float text_x, float text_y, int ownerDraw, int ownerDrawFlags, int align, float speial, float scale, vec4_t color, qhandle_t shader, int textStyle);
+
+//void Wolfcam_Draw2D (void);
+void Wolfcam_ColorForHealth (vec4_t hcolor);
+void Wolfcam_AddViewWeapon (void);
+
+void Wolfcam_TransitionPlayerState (void);
+
+void Wolfcam_ZoomIn (void);
+void Wolfcam_ZoomOut (void);
+int Wolfcam_CalcFov (void);
+int Wolfcam_OffsetThirdPersonView (void);
+int Wolfcam_OffsetFirstPersonView (void);
+
+void Wolfcam_EntityEvent (centity_t *cent, vec3_t position);
+
+//void Wolfcam_DrawFollowing (void);
+//void Wolfcam_DrawCrosshairNames (void);
+
+void wolfcam_etpro_command (const char *cmd);
+
+void Wolfcam_DamageBlendBlob (void);
+void Wolfcam_DrawActive( stereoFrame_t stereoView );
+void Wolfcam_MarkValidEntities (void);
+
+void Wolfcam_LogMissileHit (int weapon, vec3_t origin, vec3_t dir, int entityNum);
+void Wolfcam_WeaponTrace (trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int skipNumber, int mask);
+qboolean Wolfcam_CalcMuzzlePoint (int entityNum, vec3_t muzzle, vec3_t forward, vec3_t right, vec3_t up, qboolean useLerp);
+qboolean Wolfcam_InterpolateEntityPosition (centity_t *cent);
+void Wolfcam_AddBoundingBox( centity_t *cent );
+void Wolfcam_ScoreData (void);
+void Wolfcam_SwitchPlayerModels (void);
+void Wolfcam_LoadModels (void);
+
+void wolfcam_log_event (centity_t *cent, vec3_t position);
+void Wolfcam_NextSnapShotSet (void);
+
+#endif // wolfcam_h_include
+
+#endif  // 0
diff -Naur cgame.orig/wolfcam_main.c cgame/wolfcam_main.c
--- cgame.orig/wolfcam_main.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_main.c	2007-09-28 08:17:01.000000000 -0400
@@ -0,0 +1,192 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+wcg_t wcg;
+wclient_t wclients[MAX_CLIENTS];
+woldclient_t woldclients[MAX_CLIENTS];
+int wnumOldClients;
+fileHandle_t wc_logfile;
+
+int wolfcam_initialSnapshotNumber;
+
+int wolfcam_gameVersion = WOLFCAM_BASEQ3;
+
+qboolean wolfcam_following;
+
+vmCvar_t wolfcam_debugErrors;
+vmCvar_t wolfcam_debugDrawGun;
+vmCvar_t wolfcam_fakelag;
+vmCvar_t wolfcam_fast_forward_timescale;
+vmCvar_t wolfcam_fast_forward_invalid_time;
+vmCvar_t wolfcam_execIntermission;
+vmCvar_t wolfcam_execShutdown;
+vmCvar_t wolfcam_wh;
+vmCvar_t wolfcam_fixedViewAngles;
+vmCvar_t wolfcam_useOriginalInterpolation;
+vmCvar_t wolfcam_drawBBox;
+
+/*
+=================
+Wolfcam_AddBoundingBox
+
+Draws a bounding box around a player.  Called from CG_Player.
+=================
+*/
+void Wolfcam_AddBoundingBox( centity_t *cent ) {
+	polyVert_t verts[4];
+	clientInfo_t *ci;
+	int i;
+	vec3_t mins = {-15, -15, -24};
+	vec3_t maxs = {15, 15, 32};
+	float extx, exty, extz;
+	vec3_t corners[8];
+	qhandle_t bboxShader, bboxShader_nocull;
+
+	if ( !wolfcam_drawBBox.integer ) {
+		return;
+	}
+
+#if 1
+	// don't draw it if it's us in first-person
+	if ( cent->currentState.number == cg.predictedPlayerState.clientNum &&
+			!cg.renderingThirdPerson ) {
+		return;
+	}
+#endif
+
+	// don't draw it for dead players
+	if ( cent->currentState.eFlags & EF_DEAD ) {
+		return;
+	}
+
+	// get the shader handles
+	bboxShader = trap_R_RegisterShader( "bbox" );
+	bboxShader_nocull = trap_R_RegisterShader( "bbox_nocull" );
+
+	// if they don't exist, forget it
+	if ( !bboxShader || !bboxShader_nocull ) {
+		//CG_Printf ("fuck no shaders\n");
+		return;
+	}
+
+	// get the player's client info
+	ci = &cgs.clientinfo[cent->currentState.clientNum];
+
+	// if it's us
+	if ( cent->currentState.number == cg.predictedPlayerState.clientNum ) {
+		// use the view height
+		maxs[2] = cg.predictedPlayerState.viewheight + 6;
+	}
+	else {
+		int x, zd, zu;
+
+		// otherwise grab the encoded bounding box
+		x = (cent->currentState.solid & 255);
+		zd = ((cent->currentState.solid>>8) & 255);
+		zu = ((cent->currentState.solid>>16) & 255) - 32;
+
+		mins[0] = mins[1] = -x;
+		maxs[0] = maxs[1] = x;
+		mins[2] = -zd;
+		maxs[2] = zu;
+	}
+
+	// get the extents (size)
+	extx = maxs[0] - mins[0];
+	exty = maxs[1] - mins[1];
+	extz = maxs[2] - mins[2];
+
+	// set the polygon's texture coordinates
+	verts[0].st[0] = 0;
+	verts[0].st[1] = 0;
+	verts[1].st[0] = 0;
+	verts[1].st[1] = 1;
+	verts[2].st[0] = 1;
+	verts[2].st[1] = 1;
+	verts[3].st[0] = 1;
+	verts[3].st[1] = 0;
+
+	// set the polygon's vertex colors
+	if ( ci->team == TEAM_RED ) {
+		for ( i = 0; i < 4; i++ ) {
+			verts[i].modulate[0] = 160;
+			verts[i].modulate[1] = 0;
+			verts[i].modulate[2] = 0;
+			verts[i].modulate[3] = 255;
+		}
+	}
+	else if ( ci->team == TEAM_BLUE ) {
+		for ( i = 0; i < 4; i++ ) {
+			verts[i].modulate[0] = 0;
+			verts[i].modulate[1] = 0;
+			verts[i].modulate[2] = 192;
+			verts[i].modulate[3] = 255;
+		}
+	}
+	else {
+		for ( i = 0; i < 4; i++ ) {
+			verts[i].modulate[0] = 0;
+			verts[i].modulate[1] = 128;
+			verts[i].modulate[2] = 0;
+			verts[i].modulate[3] = 255;
+		}
+	}
+
+	VectorAdd( cent->lerpOrigin, maxs, corners[3] );
+
+	VectorCopy( corners[3], corners[2] );
+	corners[2][0] -= extx;
+
+	VectorCopy( corners[2], corners[1] );
+	corners[1][1] -= exty;
+
+	VectorCopy( corners[1], corners[0] );
+	corners[0][0] += extx;
+
+	for ( i = 0; i < 4; i++ ) {
+		VectorCopy( corners[i], corners[i + 4] );
+		corners[i + 4][2] -= extz;
+	}
+
+	// top
+	VectorCopy( corners[0], verts[0].xyz );
+	VectorCopy( corners[1], verts[1].xyz );
+	VectorCopy( corners[2], verts[2].xyz );
+	VectorCopy( corners[3], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader, 4, verts );
+
+	// bottom
+	VectorCopy( corners[7], verts[0].xyz );
+	VectorCopy( corners[6], verts[1].xyz );
+	VectorCopy( corners[5], verts[2].xyz );
+	VectorCopy( corners[4], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader, 4, verts );
+
+	// top side
+	VectorCopy( corners[3], verts[0].xyz );
+	VectorCopy( corners[2], verts[1].xyz );
+	VectorCopy( corners[6], verts[2].xyz );
+	VectorCopy( corners[7], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader_nocull, 4, verts );
+
+	// left side
+	VectorCopy( corners[2], verts[0].xyz );
+	VectorCopy( corners[1], verts[1].xyz );
+	VectorCopy( corners[5], verts[2].xyz );
+	VectorCopy( corners[6], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader_nocull, 4, verts );
+
+	// right side
+	VectorCopy( corners[0], verts[0].xyz );
+	VectorCopy( corners[3], verts[1].xyz );
+	VectorCopy( corners[7], verts[2].xyz );
+	VectorCopy( corners[4], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader_nocull, 4, verts );
+
+	// bottom side
+	VectorCopy( corners[1], verts[0].xyz );
+	VectorCopy( corners[0], verts[1].xyz );
+	VectorCopy( corners[4], verts[2].xyz );
+	VectorCopy( corners[5], verts[3].xyz );
+	trap_R_AddPolyToScene( bboxShader_nocull, 4, verts );
+}
diff -Naur cgame.orig/wolfcam_playerstate.c cgame/wolfcam_playerstate.c
--- cgame.orig/wolfcam_playerstate.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_playerstate.c	2009-12-05 17:12:15.000000000 -0500
@@ -0,0 +1,397 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+int wolfcam_find_client_to_follow (void)
+{
+    int i;
+    qboolean foundNewClient;
+    qboolean foundBackupClient;
+    int backupClient = -1;  // cg.snap->ps.clientNum acts as second backup client
+
+    if (wclients[wcg.selectedClientNum].currentValid)
+        return wcg.selectedClientNum;
+
+    foundNewClient = qfalse;
+    foundBackupClient = qfalse;
+
+    for (i = wcg.clientNum;  i < MAX_CLIENTS;  i++) {
+        if (!cgs.clientinfo[i].infoValid)
+            continue;
+        if (!wclients[i].currentValid)
+            continue;
+        //if (i == cg.snap->ps.clientNum  &&  wolfcam_avoidDemoPov.integer)
+        if (i == cg.clientNum  &&  1)  //wolfcam_avoidDemoPov.integer)
+            continue;
+
+        if (cgs.clientinfo[i].team != cgs.clientinfo[wcg.selectedClientNum].team  &&  1)  { //wolfcam_tryToStickWithTeam.integer) {
+            if (!foundBackupClient) {
+                foundBackupClient = qtrue;
+                backupClient = i;
+            }
+            continue;
+        }
+        foundNewClient = qtrue;
+        break;
+    }
+
+    if (foundNewClient)
+        return i;
+
+    for (i = 0;  i < wcg.clientNum;  i++) {
+        if (!cgs.clientinfo[i].infoValid)
+            continue;
+        if (!wclients[i].currentValid)
+            continue;
+        //if (i == cg.snap->ps.clientNum  &&  wolfcam_avoidDemoPov.integer)
+        if (i == cg.clientNum  &&  1)  //wolfcam_avoidDemoPov.integer)
+            continue;
+        if (cgs.clientinfo[i].team != cgs.clientinfo[wcg.selectedClientNum].team  &&  1)  { //wolfcam_tryToStickWithTeam.integer) {
+            if (!foundBackupClient) {
+                foundBackupClient = qtrue;
+                backupClient = i;
+            }
+            continue;
+        }
+        foundNewClient = qtrue;
+        break;
+    }
+
+    if (foundNewClient)
+        return i;
+
+    if (foundBackupClient)
+        return backupClient;
+
+    if (wclients[wcg.clientNum].currentValid)
+        return wcg.clientNum;
+
+    return cg.snap->ps.clientNum;
+}
+
+
+
+//FIXME wolfcam move stuff from Wolfcam_Offset* here
+void Wolfcam_TransitionPlayerState (void)
+{
+    clientInfo_t *ci;
+    centity_t *cent;
+    entityState_t *cs, *os;
+    wclient_t *wc;
+    //qboolean wasCrouching, wasStanding;
+    //qboolean isCrouching, isStanding;
+    //float duckChange;
+    //vec3_t velocity;
+    float bobmove = 0.0;
+    //int i;
+    //int grenadeTimeLeft;
+    int oldClientNum;
+
+    oldClientNum = wcg.clientNum;
+
+    if (wclients[wcg.selectedClientNum].currentValid) {
+        wcg.clientNum = wcg.selectedClientNum;
+    } else if (!wclients[wcg.clientNum].currentValid  ||  wcg.clientNum == cg.snap->ps.clientNum) {
+        //wcg.clientNum = wolfcam_find_next_valid_team_client (wcg.clientNum);
+        //wcg.clientNum = wolfcam_find_next_valid_team_client (cg.snap->ps.clientNum);
+        wcg.clientNum = wolfcam_find_client_to_follow();
+    }
+
+    ci = &cgs.clientinfo[wcg.clientNum];
+    cent = &cg_entities[wcg.clientNum];
+    cs = &cent->currentState;
+    wc = &wclients[wcg.clientNum];
+    os = &wc->esPrev;
+
+    if (wcg.clientNum != oldClientNum)
+        memcpy (os, cs, sizeof(entityState_t));
+
+#if 0  // wolfcam testing
+    //FIXME wolfcam, as 'follow' option, 
+    //FIXME wolfcam not in this function
+    //FIXME wolfcam finer grained cg_main timescale (don't skip too far ahead)
+    if ((wcg.fastForwarding  &&  cg.clientNum == wcg.clientNum)  ||  ci->team == TEAM_SPECTATOR) {
+        trap_Cvar_Set ("s_volume", wcg.oldVolume);
+        trap_Cvar_Set ("timescale", wcg.oldTimescale);
+        trap_SendConsoleCommand ("s_stop\n");
+        wcg.fastForwarding = qfalse;
+    }
+
+    if (cg.clientNum != wcg.clientNum) {  //if (wcg.fastForward) {
+        if (cg.time - wcg.validTime > (wolfcam_fast_forward_invalid_time.value * 1000.0)) {
+            if (!wcg.fastForwarding) {
+                //CG_Printf ("timescale: %f\n", cg_timescale.value);
+                trap_Cvar_VariableStringBuffer ("s_volume", wcg.oldVolume, sizeof(wcg.oldVolume));
+                trap_Cvar_VariableStringBuffer ("timescale", wcg.oldTimescale, sizeof(wcg.oldTimescale));
+                trap_Cvar_Set ("s_volume", "0");
+                trap_Cvar_Set ("timescale", wolfcam_fast_forward_timescale.string);
+                wcg.fastForwarding = qtrue;
+            }
+        } else {
+            if (wcg.fastForwarding) {
+                //CG_Printf ("^3 setting timescale back: %s", wcg.oldTimescale);
+                trap_Cvar_Set ("s_volume", wcg.oldVolume);
+                trap_Cvar_Set ("timescale", wcg.oldTimescale);
+                trap_SendConsoleCommand ("s_stop\n");
+                wcg.fastForwarding = qfalse;
+            }
+        }
+    }
+#endif
+
+    if (wc->weapAnimTimer > 0) {
+        wc->weapAnimTimer -= cg.frametime;
+        if (wc->weapAnimTimer < 0)
+            wc->weapAnimTimer = 0;
+    }
+    //Com_Printf ("%d\n", cg.frametime);
+
+#if 0  //FIXME wolfcam
+    // OSP - MV client handling
+    if(cg.mvTotalClients > 0) {
+        if (ps->clientNum != ops->clientNum) {
+            cg.thisFrameTeleport = qtrue;
+
+            // clear voicechat
+            cg.predictedPlayerEntity.voiceChatSpriteTime = 0;
+            // CHECKME: should we do this here?
+            cg_entities[ps->clientNum].voiceChatSpriteTime = 0;
+
+            *ops = *ps;
+        }
+        CG_CheckLocalSounds( ps, ops );
+        return;
+    }
+#endif
+
+    // check for changing follow mode
+    //FIXME wolfcam todo
+#if 0
+    if ( ps->clientNum != ops->clientNum ) {
+        cg.thisFrameTeleport = qtrue;
+
+        // clear voicechat
+        cg.predictedPlayerEntity.voiceChatSpriteTime = 0;
+        cg_entities[ps->clientNum].voiceChatSpriteTime = 0;
+
+        // make sure we don't get any unwanted transition effects
+        *ops = *ps;
+
+        // DHM - Nerve :: After Limbo, make sure and do a CG_Respawn
+        if ( ps->clientNum == cg.clientNum )
+            ops->persistant[PERS_SPAWN_COUNT]--;
+    }
+#endif
+
+#if 0  // wolfcam handled in events
+    if (cs->eFlags & EF_FIRING) {
+        wolfcam_lastFiredWeaponTime = 0;
+        wolfcam_weaponFireTime += cg.frametime;
+    } else {
+        if (wolfcam_weaponFireTime > 500  && wolfcam_weaponFireTime) {  // wolfcam huh?
+            wolfcam_lastFiredWeaponTime = cg.time;
+        }
+        wolfcam_weaponFireTime = 0;
+    }
+#endif
+
+    //FIXME wolfcam EF_FIRING problem with rapid taps
+    if (cs->eFlags & EF_FIRING  &&  !(os->eFlags & EF_FIRING)) {
+#if 0  // wolfcam-q3
+        //CG_Printf ("^3now firing...  %d  old:%d\n", cs->weapon, os->weapon);
+        if (cs->weapon == WP_GRENADE_LAUNCHER   ||
+            cs->weapon == WP_GRENADE_PINEAPPLE  ||
+            cs->weapon == WP_DYNAMITE) {
+            //CG_Printf ("grenade time set: %d\n", cg.time);
+            wc->grenadeDynoTime = cg.time;
+        }
+#endif
+    }
+
+    if (!(cs->eFlags & EF_FIRING))
+        wc->grenadeDynoTime = 0;
+
+#if 0
+    if (os->weapon != cs->weapon) {
+        wolfcam_weaponSwitchTime = cg.time;
+        wolfcam_oldweapon = os->weapon;
+    }
+#endif
+    // damage events (player is getting wounded)
+    //FIXME wolfcam
+#if 0
+    if( ps->damageEvent != ops->damageEvent && ps->damageCount ) {
+        CG_DamageFeedback( ps->damageYaw, ps->damagePitch, ps->damageCount );
+    }
+#endif
+
+    // respawning 
+    //FIXME wolfcam
+#if 0
+    if( ps->persistant[PERS_SPAWN_COUNT] != ops->persistant[PERS_SPAWN_COUNT]) {
+        CG_Respawn( ps->persistant[PERS_REVIVE_COUNT] != ops->persistant[PERS_REVIVE_COUNT] ? qtrue : qfalse );
+    }
+#endif
+
+#if 0  //FIXME wolfcam
+    if ( cg.mapRestart ) {
+        CG_Respawn( qfalse );
+        cg.mapRestart = qfalse;
+    }
+
+    if ( cg.snap->ps.pm_type != PM_INTERMISSION 
+         && ps->persistant[PERS_TEAM] != TEAM_SPECTATOR ) {
+        CG_CheckLocalSounds( ps, ops );
+    }
+
+#endif
+
+    // check for going low on ammo
+    //CG_CheckAmmo();
+    //Com_Printf("testing check ammo\n");
+
+
+    //FIXME wolfcam
+    // run events
+    //CG_CheckPlayerstateEvents( ps, ops );
+
+    // smooth the ducking viewheight change
+
+#if 0
+    wasCrouching = wasStanding = qfalse;
+
+    if (os->eFlags & EF_CROUCHING)
+        wasCrouching = qtrue;
+    else
+        wasStanding = qtrue;
+
+    isCrouching = isStanding = qfalse;
+
+    if (cs->eFlags & EF_CROUCHING)
+        isCrouching = qtrue;
+    else
+        isStanding = qtrue;
+
+    duckChange = 0;
+
+    if (isCrouching) {
+        if (wasStanding)
+            duckChange = CROUCH_VIEWHEIGHT - DEFAULT_VIEWHEIGHT;
+    } else if (isStanding) {
+        if (wasCrouching)
+            duckChange = DEFAULT_VIEWHEIGHT - CROUCH_VIEWHEIGHT;
+    }
+
+    if (duckChange) {
+        wc->duckChange = duckChange;
+        wc->duckTime = cg.time;
+    }
+#endif
+
+#if 1  //FIXME wolfcam doesn't seem to work
+ {
+     vec3_t velocity;
+
+     //BG_EvaluateTrajectoryDelta (&cs->pos, cg.time, velocity, qfalse, -1);
+     //BG_EvaluateTrajectoryDelta (&cs->pos, cg.time, velocity);
+     VectorCopy (cs->pos.trDelta, velocity);
+ 
+     if (wcg.clientNum != cg.snap->ps.clientNum)
+         wc->xyspeed = sqrt (velocity[0] * velocity[0] + velocity[1] * velocity[1]);
+     else  {// view what demo pov
+         playerState_t *ps = &cg.predictedPlayerState;
+         wc->xyspeed = sqrt( ps->velocity[0] * ps->velocity[0] +
+                             ps->velocity[1] * ps->velocity[1] );
+     }
+ }
+#endif
+    //    Com_Printf ("%f %f %f\n", wolfcam_prevOrigin[0], wolfcam_prevOrigin[1], wolfcam_prevOrigin[2]);
+#if 0
+    {
+        float xv, yv;
+
+        //xv = (cent->lerpOrigin[0] - wolfcam_prevOrigin[0]) / cg.frametime;
+        //yv = (cent->lerpOrigin[1] - wolfcam_prevOrigin[1]) / cg.frametime;
+        //FIXME wolfcam 16 - 8
+        xv = (cent->lerpOrigin[0] - wolfcam_prevOrigins[16 - 16][0]) / (cg.time - wolfcam_prevTimes[16 - 16]) * 1000;
+        yv = (cent->lerpOrigin[1] - wolfcam_prevOrigins[16 - 16][1]) / (cg.time - wolfcam_prevTimes[16 - 16]) * 1000;
+        wolfcam_xyspeed = sqrt ( xv * xv   +   yv * yv);
+        //wolfcam_xyspeed = sqrt(xv * xv)   +  sqrt(yv * yv);
+        //wolfcam_xyspeed = sqrt (xv * yv);
+        //wolfcam_xyspeed *= 1000;
+        //wolfcam_xyspeed *= 1000;
+    }
+    //wolfcam_xyspeed = 300;
+#endif
+
+    // wc->psbobCyle from bg_pmove.c
+#if 0  //FIXME wolfcam detect "crash landing"
+    if (crash_land)  // PM_CrsahLand ()
+        wc->psbobCycle = 0;
+#endif
+    // PM_Footsteps ()
+    //  if mg42 pm->ps->persistant[PERS_HWEAPON_USE], swimming, DEAD, in the air, then return
+
+    //FIXME wolfcam, if not trying to move:
+#if 0
+    if ( !pm->cmd.forwardmove && !pm->cmd.rightmove ) {
+        if (  pm->xyspeed < 5 ) {
+            pm->ps->bobCycle = 0;   // start at beginning of cycle again
+        }
+        if (pm->xyspeed > 120) {
+            return; // continue what they were doing last frame, until we stop
+        }
+        /* etc .. */
+    }
+#endif
+
+    if (wc->xyspeed < 5) {
+        wc->psbobCycle = 0;
+        bobmove = 0.0;
+    } else if (0)  //(cs->eFlags & EF_CROUCHING)  //FIXME wolfcam-q3
+        bobmove = 0.5;
+    /*FIXME wolfcam else if (walking) {
+      bobmove = 0.3;
+}
+    */
+    else
+        bobmove = 0.4;
+    //pm->ps->bobCycle = (int)( old + bobmove * pml.msec ) & 255;
+    //FIXME wolfcam  pml.msec relation to cg.frametime ?
+    //    wolfcam_psbobCycle = (int) (wolfcam_psbobCycle + bobmove * cg.frametime ) & 255;
+    //wolfcam_psbobCycle = (int) (wolfcam_psbobCycle + bobmove * (cg.frametime * 1000)) & 255;
+    wc->psbobCycle = (int) (wc->psbobCycle + bobmove * (cg.frametime * 1)) & 255;
+    //Com_Printf ("wolfcam_psbobCycle: %d    ps->bobCycle: %d\n", wolfcam_psbobCycle, cg.predictedPlayerState.bobCycle);
+    //Com_Printf ("wolfcam_xyspeed: %f  cg.xyspeed: %f\n", wolfcam_xyspeed, cg.xyspeed);
+
+
+    if (wc->bobfracsin > 0  &&  !(wc->psbobCycle)) {
+        wc->lastvalidBobcycle = wc->bobcycle;
+        wc->lastvalidBobfracsin = wc->bobfracsin;
+    }
+    wc->bobcycle = (wc->psbobCycle & 128) >> 7;
+    wc->bobfracsin = fabs( sin( (wc->psbobCycle & 127 ) / 127.0 * M_PI ));
+
+    //Com_Printf ("wolfcam_bobcycle: %d  cg.bobcycle: %d\n", wolfcam_bobcycle, cg.bobcycle);
+    //    Com_Printf ("wolfcam_bobfracsin: %f  cg.bobfracsin: %f\n", wolfcam_bobfracsin, cg.bobfracsin);
+
+#if 0
+    for (i = 1;  i < WOLFCAM_MAXBACKUPS;  i++) {
+        memcpy (&(wolfcam_prevOrigins[i - 1]), &(wolfcam_prevOrigins[i]), sizeof(vec3_t));
+        wolfcam_prevTimes[i - 1] = wolfcam_prevTimes[i];
+        memcpy (&(wolfcam_prevEs[i - 1]), &(wolfcam_prevEs[i]), sizeof(entityState_t));
+    }
+    memcpy (&(wolfcam_prevOrigins[WOLFCAM_MAXBACKUPS - 1]), cent->lerpOrigin, sizeof(vec3_t));
+    wolfcam_prevTimes[WOLFCAM_MAXBACKUPS - 1] = cg.time;
+    memcpy (&wolfcam_esPrev, cs, sizeof(entityState_t));
+    memcpy (&(wolfcam_prevEs[WOLFCAM_MAXBACKUPS - 1]), cs, sizeof(entityState_t));
+#endif
+
+    memcpy (os, cs, sizeof(entityState_t));
+
+#if 0
+    /////////////////////  sldkfjsldkfj
+    if ((cs->eFlags & EF_TELEPORT_BIT) != (wolfcam_prevEs[WOLFCAM_MAXBACKUPS - 1].eFlags & EF_TELEPORT_BIT)) {
+        Com_Printf ("^3teleport\n");
+    }
+#endif
+}
diff -Naur cgame.orig/wolfcam_predict.c cgame/wolfcam_predict.c
--- cgame.orig/wolfcam_predict.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_predict.c	2007-08-24 12:36:36.000000000 -0400
@@ -0,0 +1,62 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+extern int cg_numSolidEntities;
+extern centity_t    *cg_solidEntities[MAX_ENTITIES_IN_SNAPSHOT];
+
+/* clientNum for calcMuzzle */
+void Wolfcam_WeaponTrace (trace_t *result, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int skipNumber, int mask)
+{
+    int addedEntities;
+    int i;
+
+    //FIXME cg.snap->ps.clientNum special case, right now just adds automaticaly
+    /* add players that have died this frame to check for killshot, and also
+     * cg.snap->ps.clientNum
+     */
+    addedEntities = 0;
+    for (i = 0;  i < MAX_CLIENTS;  i++) {
+        if (!cgs.clientinfo[i].infoValid)
+            continue;
+        if (!cg_entities[i].currentValid  &&  i != cg.snap->ps.clientNum)
+            continue;
+        //if (cg_entities[i].currentState.solid == 4200463)
+        //    continue;
+        if (cg_entities[i].currentState.solid != 0)
+            continue;
+        //if (wclients[i].deathTime != cg.time  &&  i != cg.snap->ps.clientNum)
+        //    continue;
+        wclients[i].oldSolid = cg_entities[i].currentState.solid;
+        cg_entities[i].currentState.solid = 4200463;
+        cg_solidEntities[cg_numSolidEntities] = &cg_entities[i];
+        cg_numSolidEntities++;
+        addedEntities++;
+
+        //CG_Printf ("--- %s\n", cgs.clientinfo[i].name);
+    }
+
+    CG_Trace (result, start, mins, maxs, end, skipNumber, mask);
+
+#if 0
+    CG_Printf ("--- %d  ", cg.time);
+    for (i = 0;  i < cg_numSolidEntities;  i++) {
+        int cn;
+
+        cn = cg_solidEntities[i]->currentState.clientNum;
+        if (cn >= MAX_CLIENTS)
+            continue;
+
+        if (!cgs.clientinfo[cg_solidEntities[i]->currentState.clientNum].infoValid)
+            continue;
+        CG_Printf ("[%s^7]  ", cgs.clientinfo[cg_solidEntities[i]->currentState.clientNum].name);
+    }
+    CG_Printf ("\n");
+#endif
+
+    for (i = cg_numSolidEntities - addedEntities;  i < cg_numSolidEntities;  i++) {
+        cg_solidEntities[i]->currentState.solid = 0;
+    }
+
+    cg_numSolidEntities -= addedEntities;
+}
+
diff -Naur cgame.orig/wolfcam_servercmds.c cgame/wolfcam_servercmds.c
--- cgame.orig/wolfcam_servercmds.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_servercmds.c	2007-09-03 13:55:32.000000000 -0400
@@ -0,0 +1,23 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+void Wolfcam_ScoreData (void)
+{
+    score_t *sc;
+    wclient_t *wc;
+    clientInfo_t *ci;
+    int i;
+
+    for (i = 0;  i < cg.numScores;  i++) {
+        sc = &cg.scores[i];
+        wc = &wclients[sc->client];
+        if (!wc->currentValid)
+            continue;
+        ci = &cgs.clientinfo[sc->client];
+        //wc->ping = sc->ping;
+        wc->serverPingAccum += sc->ping;
+        wc->serverPingSamples++;
+        //wc->time = sc->time;
+        //wc->score = sc->score;
+    }
+}
diff -Naur cgame.orig/wolfcam_snapshot.c cgame/wolfcam_snapshot.c
--- cgame.orig/wolfcam_snapshot.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_snapshot.c	2009-12-05 17:12:44.000000000 -0500
@@ -0,0 +1,173 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+static void Wolfcam_CheckWarp (void)
+{
+    int clientNum;
+    int i;
+    snapshot_t *oldsnap;
+
+    if (wcg.curSnapshotNumber < 2)
+        return;
+
+    //return;
+    //FIXME wolfcam this is where you do player transitions, although no lerp yet
+    oldsnap = &wcg.snaps[(wcg.curSnapshotNumber - 2) & MAX_SNAPSHOT_MASK];
+
+    // check for warping
+    for (clientNum = 0;  clientNum < MAX_CLIENTS;  clientNum++) {
+        clientInfo_t *ci;
+        centity_t *cent;
+        entityState_t *es;
+        entityState_t *oldes = NULL;  // = NULL;
+        vec3_t oldPosition;
+        vec3_t newPosition;
+        float xv;
+        float yv;
+        float xyspeed;
+		float xyvel;
+		float xyerr;
+		float velerr;
+        int timeDiff;
+        int oldGroundEntityNum;
+        qboolean foundOldClient;
+
+        ci = &cgs.clientinfo[clientNum];
+        cent = &cg_entities[clientNum];
+        es = &cent->currentState;
+
+        if (!ci->infoValid  ||  !cent->currentValid) {
+            if (clientNum != cg.snap->ps.clientNum) {
+				wclients[clientNum].invalidCount++;
+                continue;
+			} 
+        }
+		wclients[clientNum].validCount++;
+
+        if (es->groundEntityNum == ENTITYNUM_NONE)
+            continue;  // in air, don't check
+
+		if (es->pos.trDelta[2] != 0.0) {
+			//CG_Printf("^2FIXME %d  trDelta[2]=%f %s\n", clientNum, es->pos.trDelta[2], ci->name);
+			continue;
+		}
+
+        foundOldClient = qfalse;
+
+        // find in old snapshot
+        if (oldsnap->ps.clientNum == clientNum) {
+            VectorCopy (oldsnap->ps.origin, oldPosition);
+            SnapVector (oldPosition);
+            oldGroundEntityNum = oldsnap->ps.groundEntityNum;
+            foundOldClient = qtrue;
+        } else {
+            for (i = 0;  i < oldsnap->numEntities;  i++) {
+                oldes = &oldsnap->entities[i];
+                if (oldes->number == clientNum) {
+                    VectorCopy (oldes->pos.trBase, oldPosition);
+                    oldGroundEntityNum = oldes->groundEntityNum;
+                    foundOldClient = qtrue;
+                    break;
+                }
+            }
+        }
+
+        if (!foundOldClient)
+            continue;
+
+		wclients[clientNum].snapshotPingSamples++;
+
+		if (clientNum == cg.snap->ps.clientNum) {
+			wclients[clientNum].snapshotPingAccum += (cg.snap->serverTime - cg.snap->ps.commandTime);
+			if (cg.snap->ps.commandTime - oldsnap->ps.commandTime == 0) {
+				wclients[clientNum].noCommandCount++;
+			}
+		} else {
+			wclients[clientNum].snapshotPingAccum += (cg.snap->serverTime - es->pos.trTime);
+			if (es->pos.trTime - oldes->pos.trTime == 0) {
+				wclients[clientNum].noCommandCount++;
+			}
+		}
+
+        if (oldGroundEntityNum == ENTITYNUM_NONE) { //(oldes->groundEntityNum == -1)
+            continue;
+		}
+
+        // have old client, do the calculation
+        if (clientNum == cg.snap->ps.clientNum) {
+            VectorCopy (cg.snap->ps.origin, newPosition);
+            SnapVector (newPosition);
+        } else
+            VectorCopy (es->pos.trBase, newPosition);
+
+        if (oldPosition[2] != newPosition[2])
+            continue;
+
+#if 0
+        CG_Printf ("%02d (%f, %f, %f)  (%f, %f, %f)   %d  %s\n",
+                   clientNum,
+                   oldPosition[0], oldPosition[1], oldPosition[2],
+                   newPosition[0], newPosition[1], newPosition[2],
+                   cg.snap->serverTime - oldsnap->serverTime,
+                   cgs.clientinfo[clientNum].name
+                   );
+#endif
+        xv = (newPosition[0] - oldPosition[0]);   // *   1000.0 / (float)(cg.snap->serverTime - oldsnap->serverTime);  // / 50.0;  // 50 ms
+        yv = (newPosition[1] - oldPosition[1]);  //  *   1000.0 / (float)(cg.snap->serverTime - oldsnap->serverTime);  // / 50.0;
+
+        // snap the vectors in case positions are from playerState
+#if 1
+        xv = (int)xv;
+        yv = (int)yv;
+#endif
+        xyspeed = sqrt (xv * xv  +  yv * yv);
+
+        timeDiff = cg.snap->serverTime - oldsnap->serverTime;
+        xyspeed *= (1000.0 / (float)timeDiff);
+
+        // give people the benifit of the doubt with respect to rounding errors
+		// position are ints with +-1 error:
+		// xyerr = sqrt (2 * 2  +  2 * 2) 
+		//         = 2.8284...
+		xyerr = 2.83 * (1000.0 / (float)timeDiff);
+
+        //CG_Printf ("%s: xv:%f  yv:%f  xyspeed:%f\n", cgs.clientinfo[clientNum].name, xv, yv, xyspeed);
+
+
+        //FIXME take into account snapped vectors and give the benifit of the doubt
+		xyvel = sqrt(es->pos.trDelta[0] * es->pos.trDelta[0]  +
+					 es->pos.trDelta[1] * es->pos.trDelta[1]);
+		//CG_Printf("%d %f\n", clientNum, xyvel);
+
+		// pm_accel: 10.0,   pm_friction: 6.0
+		velerr = (10.0 * (1000.0 / (float)timeDiff) * 320) -
+			     (320.0 * 6.0 * (1000.0 / (float)timeDiff));
+		//FIXME check that they aren't hitting something
+		if (xyspeed > 320.0 - velerr) {
+        // assume max error 4
+        //if (xyspeed > 352.0 + 40.0) {
+        if (xyspeed > 320.0 + xyerr) {
+            wclients[clientNum].warp++;
+            //wclients[clientNum].warpaccum = (xyspeed + wclients[clientNum].warpaccum) / wclients[clientNum].warp;
+            wclients[clientNum].warpaccum += xyspeed;
+            //CG_Printf ("%02d   %s  ^7%f\n", clientNum, cgs.clientinfo[clientNum].name, xyspeed);
+#if 0
+            if (clientNum == wcg.clientNum)
+                CG_Printf ("^3warp %f  ^7%s\n", xyspeed, ci->name);
+#endif
+		//} else if (xyspeed > 352.0 - 40.0) {  // give the the benifit of the doubt
+        } else if (xyspeed > 320.0 - xyerr) {  // give the the benifit of the doubt
+            wclients[clientNum].nowarp++;
+        }
+		}
+    }
+}
+
+void Wolfcam_NextSnapShotSet (void)
+{
+    //return;
+    //Wolfcam_MarkValidEntities ();  //FIXME yes, want here
+    Wolfcam_CheckWarp ();
+}
+
+//
diff -Naur cgame.orig/wolfcam_view.c cgame/wolfcam_view.c
--- cgame.orig/wolfcam_view.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_view.c	2009-12-05 17:14:52.000000000 -0500
@@ -0,0 +1,625 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+void Wolfcam_SwitchPlayerModels (void)
+{
+	//int i;
+
+	//FIXME allow followed player with his own model
+}
+
+void Wolfcam_LoadModels (void)
+{
+	char modelStr[MAX_QPATH];
+	char *skin;
+
+	//FIXME modification count can't be changed by cgame?
+	if (wolfcam_enemyModel.modificationCount) {
+		EM_Loaded = 0;
+		wolfcam_enemyModel.modificationCount = 0;
+	}
+
+	if (EM_Loaded == 0 && wolfcam_enemyModel.string && *wolfcam_enemyModel.string) {
+		Q_strncpyz (modelStr, wolfcam_enemyModel.string, sizeof(modelStr));
+		if ((skin = strchr(modelStr, '/')) == NULL) {
+			//Com_Printf("using default\n");
+			skin = "default";
+		} else
+			*skin++ = 0;
+
+		//memcpy(&EM_ModelInfo, ci, sizeof(EM_ModelInfo));
+
+		Q_strncpyz(EM_ModelInfo.modelName, modelStr, sizeof(EM_ModelInfo.modelName));
+		Q_strncpyz(EM_ModelInfo.skinName, skin, sizeof(EM_ModelInfo.skinName));
+
+		if (cgs.gametype >= GT_TEAM  &&  Q_stricmp(EM_ModelInfo.skinName, "pm") != 0) {
+			//FIXME why is this here
+			//Q_strncpyz(EM_ModelInfo.skinName, "default", sizeof(EM_ModelI\nfo.skinName));
+		}
+
+		Q_strncpyz(EM_ModelInfo.headModelName, EM_ModelInfo.modelName, sizeof(EM_ModelInfo.headModelName));
+		Q_strncpyz(EM_ModelInfo.headSkinName, EM_ModelInfo.skinName, sizeof(EM_ModelInfo.headSkinName));
+
+		if (CG_RegisterClientModelname(&EM_ModelInfo, EM_ModelInfo.modelName, EM_ModelInfo.skinName, EM_ModelInfo.headModelName, EM_ModelInfo.headSkinName, "")) {
+			const char *dir, *fallback, *s;
+			int i;
+
+			EM_Loaded = 1;
+			EM_ModelInfo.newAnims = qfalse;
+			if (EM_ModelInfo.torsoModel) {
+				orientation_t tag;
+				// if the torso model has the "tag_flag"
+				if (trap_R_LerpTag(&tag, EM_ModelInfo.torsoModel, 0, 0, 1, "tag_flag")) {
+					EM_ModelInfo.newAnims = qtrue;
+				}
+			}
+
+			// sounds
+			dir = EM_ModelInfo.modelName;
+			fallback = (cgs.gametype >= GT_TEAM) ? DEFAULT_TEAM_MODEL : DEFAULT_MODEL;
+
+			for (i = 0;  i < MAX_CUSTOM_SOUNDS;  i++) {
+				s = cg_customSoundNames[i];
+				if (!s) {
+					break;
+				}
+				EM_ModelInfo.sounds[i] = 0;
+				// if the model didn't load use the sounds of the default model
+				EM_ModelInfo.sounds[i] = trap_S_RegisterSound(va("sound/player/%s/%s", dir, s + 1), qfalse);
+				if (!EM_ModelInfo.sounds[i])
+					EM_ModelInfo.sounds[i] = trap_S_RegisterSound(va("sound/player/%s/%s", fallback, s + 1), qfalse);
+			}
+		}
+		else
+			EM_Loaded = -1;
+	}
+
+	if (wolfcam_enemyColors.modificationCount) {
+		EC_Loaded = 0;
+		wolfcam_enemyColors.modificationCount = 0;
+	}
+	if (EC_Loaded == 0  &&  wolfcam_enemyColors.string  &&  strlen(wolfcam_enemyColors.string) >= 4) {
+		SC_ParseEnemyColorsFromStr(wolfcam_enemyColors.string, EC_Colors);
+		EC_Loaded = 1;
+	}
+	else {
+		EC_Loaded = -1;
+	}
+}
+
+#define FOCUS_DISTANCE  400     //800   //512
+int Wolfcam_OffsetThirdPersonView (void)
+{
+        vec3_t          forward, right, up;
+        vec3_t          view;
+        vec3_t          focusAngles;
+        trace_t         trace;
+        static vec3_t   mins = { -4, -4, -4 };
+        static vec3_t   maxs = { 4, 4, 4 };
+        vec3_t          focusPoint;
+        float           focusDist;
+        float           forwardScale, sideScale;
+        clientInfo_t *ci;
+        centity_t *cent;
+
+        ci = &cgs.clientinfo[wcg.clientNum];
+        cent = &cg_entities[wcg.clientNum];
+
+        //cent->currentState.eFlags &= ~EF_NODRAW;
+        //cent->nextState.eFlags &= ~EF_NODRAW;
+
+        VectorCopy (cg.refdef.vieworg, wcg.vieworgDemo);
+        VectorCopy (cg.refdefViewAngles, wcg.refdefViewAnglesDemo);
+
+        VectorCopy (cent->lerpOrigin, cg.refdef.vieworg);
+        VectorCopy (cent->lerpAngles, cg.refdefViewAngles);
+
+        cg.refdef.vieworg[2] += DEFAULT_VIEWHEIGHT;
+        VectorCopy (cg.refdefViewAngles, focusAngles);
+        if (cent->currentState.eFlags & EF_DEAD) {
+            // rain - #254 - force yaw to 0 if we're tracking a medic
+            //if( cg.snap->ps.viewlocked != 7 ) {  //FIXME wolfcam
+            if (1) {
+                focusAngles[YAW] = SHORT2ANGLE(cg.predictedPlayerState.stats[STAT_DEAD_YAW]);  //FIXME wolfencam
+                cg.refdefViewAngles[YAW] = SHORT2ANGLE(cg.predictedPlayerState.stats[STAT_DEAD_YAW]);
+            }
+        }
+
+        if ( focusAngles[PITCH] > 45 )
+            focusAngles[PITCH] = 45; 
+        AngleVectors( focusAngles, forward, NULL, NULL );
+
+        if (0) {  //FIXME wolfcam (cg_thirdPerson.integer == 2 ) 
+            //VectorCopy( cg.predictedPlayerState.origin, focusPoint );
+        } else
+            VectorMA( cg.refdef.vieworg, FOCUS_DISTANCE, forward, focusPoint );
+
+        VectorCopy (cg.refdef.vieworg, view);
+        view[2] += 8;
+        cg.refdefViewAngles[PITCH] *= 0.5;
+        AngleVectors( cg.refdefViewAngles, forward, right, up );
+        forwardScale = cos( cg_thirdPersonAngle.value / 180 * M_PI );
+        sideScale = sin( cg_thirdPersonAngle.value / 180 * M_PI );
+        VectorMA( view, -cg_thirdPersonRange.value * forwardScale, forward, view);
+        VectorMA( view, -cg_thirdPersonRange.value * sideScale, right, view );
+        // trace a ray from the origin to the viewpoint to make sure the view isn't
+        // in a solid block.  Use an 8 by 8 block to prevent the view from near clipping anything
+
+        CG_Trace( &trace, cg.refdef.vieworg, mins, maxs, view, wcg.clientNum, MASK_SOLID );
+        if ( trace.fraction != 1.0 ) {
+            VectorCopy( trace.endpos, view );
+            view[2] += (1.0 - trace.fraction) * 32;
+            // try another trace to this position, because a tunnel may have the ceiling close enough that this is poking out
+            CG_Trace( &trace, cg.refdef.vieworg, mins, maxs, view, wcg.clientNum, MASK_SOLID);
+            VectorCopy( trace.endpos, view );
+        }
+        VectorCopy( view, cg.refdef.vieworg);
+        // select pitch to look at focus point from vieword
+        VectorSubtract( focusPoint, cg.refdef.vieworg, focusPoint );
+        focusDist = sqrt( focusPoint[0] * focusPoint[0] + focusPoint[1] * focusPoint[1] );
+        if ( focusDist < 1 ) {
+            focusDist = 1;  // should never happen
+        }
+        cg.refdefViewAngles[PITCH] = -180 / M_PI * atan2( focusPoint[2], focusDist);
+        cg.refdefViewAngles[YAW] -= cg_thirdPersonAngle.value;
+
+        AnglesToAxis (cg.refdefViewAngles, cg.refdef.viewaxis );
+
+        //VectorCopy (cg.refdef.vieworg, cg.refdef_current->vieworg);
+        //AnglesToAxis (cg.refdefViewAngles, cg.refdef_current->viewaxis);
+        //FIXME wolfcam CG_CalcFov
+        return 0;
+}
+
+/*
+===============
+Wolfcam_OffsetFirstPersonView
+
+Sets cg.refdef view values if following other players
+===============
+*/
+int Wolfcam_OffsetFirstPersonView (void)
+{
+    int clientNum;
+    clientInfo_t *ci;
+    centity_t *cent;
+    entityState_t *es;
+    wclient_t *wc;
+    float ratio;
+    float v_dmg_pitch;
+    //qboolean wasBinocZooming;
+    int timeDelta;
+    qboolean notDrawing;
+    float bob;
+    float speed;
+    float delta;
+    qboolean                useLastValidBob = qfalse;
+    int anim;
+    
+
+    clientNum = wcg.clientNum;
+
+    ci = &cgs.clientinfo[clientNum];
+    cent = &cg_entities[clientNum];
+    es = &cent->currentState;
+    wc = &wclients[wcg.clientNum];
+
+    anim = cent->currentState.legsAnim & ~ANIM_TOGGLEBIT;
+
+    if (wcg.clientNum == cg.snap->ps.clientNum) {
+        cg.renderingThirdPerson = 0;
+        trap_Cvar_Set ("cg_thirdPerson", "0");
+    } else {
+        cg.renderingThirdPerson = 1;
+        trap_Cvar_Set ("cg_thirdPerson", "1");
+    }
+
+    notDrawing = cent->currentState.eFlags & EF_NODRAW;
+    cent->currentState.eFlags |= EF_NODRAW;
+    cent->nextState.eFlags |= EF_NODRAW;
+
+
+    VectorCopy (cent->lerpOrigin, cg.refdef.vieworg);
+    VectorCopy (cent->lerpAngles, cg.refdefViewAngles);
+
+    // CG_TransitionPlayerState for wcg.clientNum
+    //FIXME wolfcam don't know
+#if 0
+    if (cent->currentState.eFlags & EF_DEAD) {
+        trap_SendConsoleCommand ("-zoom\n");
+    }
+#endif
+
+#if 0
+    wasBinocZooming = qfalse;
+    if (wolfcam_esPrev.eFlags & EF_ZOOMING  &&  wolfcam_esPrev.weapon == WP_BINOCULARS) {
+        wasBinocZooming = qtrue;
+    }
+
+    if (wasBinocZooming == qfalse  &&  cent->currentState.weapon == WP_BINOCULARS  &&  cent->currentState.eFlags & EF_ZOOMING) {
+        wolfcam_binocZoomTime = cg.time;
+        Com_Printf ("ent zooming with binocs\n");
+    }
+#endif
+
+#if 1
+    // add view height
+    //if (es->eFlags & EF_CROUCHING) {
+    if (anim == LEGS_WALKCR || anim == LEGS_IDLECR) {
+        cg.refdef.vieworg[2] += CROUCH_VIEWHEIGHT;
+        //cg.refdef.vieworg[2] += CROUCH_VIEWHEIGHT;
+        //Com_Printf ("test.....\n");
+    }
+    else {
+        cg.refdef.vieworg[2] += DEFAULT_VIEWHEIGHT;
+        //cg.refdef.vieworg[2] += DEFAULT_VIEWHEIGHT;
+        //Com_Printf ("test.....\n");
+    }
+#endif
+
+    timeDelta = cg.time - wc->duckTime;
+    {
+        if (timeDelta < 0)
+            wc->duckTime = cg.time - DUCK_TIME;
+        if (timeDelta < DUCK_TIME) {
+            cg.refdef.vieworg[2] -= wc->duckChange * (DUCK_TIME - timeDelta) / DUCK_TIME;
+        }
+    }
+
+#if 0
+    //if (es->eFlags & EF_DEAD  &&  ci->infoValid  &&  !notDrawing) {
+    if (!cent->currentValid  ||  es->eFlags & EF_DEAD) {
+        return qfalse;
+    }
+#endif
+
+    //FIXME  fall, stepOffset?
+
+    // add angles based on bob
+
+    //    if (cent->currentValid) {
+    if (wclients[wcg.clientNum].currentValid) {
+    // make sure the bob is visible even at low speeds
+    speed = wc->xyspeed > 200 ? wc->xyspeed : 200;
+
+
+    /////////////////////
+    if( !wc->bobfracsin  &&  wc->lastvalidBobfracsin > 0 ) {
+        // 200 msec to get back to center from 1
+        // that's 1/200 per msec = 0.005 per msec
+        wc->lastvalidBobfracsin -= 0.005 * cg.frametime;
+        useLastValidBob = qtrue;
+    }
+       
+    //    delta = useLastValidBob ? wolfcam_lastvalidBobfracsin * cg_bobpitch.value * speed : cg.bobfracsin * cg_bobpitch.value * speed;
+    delta = useLastValidBob ? wc->lastvalidBobfracsin * cg_bobpitch.value * speed : wc->bobfracsin * cg_bobpitch.value * speed;
+
+    //if (es->eFlags & EF_CROUCHING)
+    if ( anim == LEGS_WALKCR || anim == LEGS_IDLECR )
+        delta *= 3;             // crouching
+    cg.refdefViewAngles[PITCH] += delta;
+    delta = useLastValidBob ? wc->lastvalidBobfracsin * cg_bobroll.value * speed : wc->bobfracsin * cg_bobroll.value * speed;
+
+    //    if (es->eFlags & EF_CROUCHING)
+    if ( anim == LEGS_WALKCR || anim == LEGS_IDLECR )
+        delta *= 3;             // crouching accentuates roll
+    if( useLastValidBob ) {
+        if( wc->lastvalidBobcycle & 1 )
+            delta = -delta;
+    } else if (wc->bobcycle & 1)
+        delta = -delta;
+    cg.refdefViewAngles[ROLL] += delta;  //FIXME wolfcam ok for weapons, sucks for regular walking
+
+
+    //FIXME wolfcam using v_dmg_pitch == kick == -5
+    v_dmg_pitch = -5;
+    ratio = cg.time - wc->bulletDamageTime;
+    if (ratio < DAMAGE_TIME  &&  !(es->eFlags & EF_DEAD)  &&  ci->infoValid) {
+        if (ratio < DAMAGE_DEFLECT_TIME) {
+            ratio /= DAMAGE_DEFLECT_TIME;
+            cg.refdefViewAngles[PITCH] += ratio * v_dmg_pitch;
+            //FIXME wolfcam ROLL
+        } else {
+            ratio = 1.0 - (ratio - DAMAGE_DEFLECT_TIME) / DAMAGE_RETURN_TIME;
+            if (ratio > 0) {
+                cg.refdefViewAngles[PITCH] += ratio * v_dmg_pitch;
+                //FIXME wolfcam ROLL
+            }
+        }
+    }
+
+    bob = wc->bobfracsin * wc->xyspeed * cg_bobup.value;
+    if (bob > 6) {
+        bob = 6;
+    }
+    cg.refdef.vieworg[2] += bob;  //FIXME wolfcam ok for weapons, not player movement
+    }
+
+#if 0
+    // ZoomSway
+    if (wc->zoomval)
+    {
+        float spreadfrac, phase;
+        
+        if (es->eFlags & EF_MG42_ACTIVE) {  //  ||  es->eFlags & EF_AAGUN_ACTIVE) {
+        } else {
+            //spreadfrac = (float)cg.snap->ps.aimSpreadScale / 255.0;
+            spreadfrac = 0.25;  //FIXME wolfcam
+            phase = cg.time / 1000.0 * ZOOM_PITCH_FREQUENCY * M_PI * 2;
+            cg.refdefViewAngles[PITCH] += ZOOM_PITCH_AMPLITUDE * sin( phase ) * (spreadfrac+ZOOM_PITCH_MIN_AMPLITUDE);
+            phase = cg.time / 1000.0 * ZOOM_YAW_FREQUENCY * M_PI * 2;
+            cg.refdefViewAngles[YAW] += ZOOM_YAW_AMPLITUDE * sin( phase ) * (spreadfrac+ZOOM_YAW_MIN_AMPLITUDE);
+        }
+    }
+#endif
+    
+    AnglesToAxis (cg.refdefViewAngles, cg.refdef.viewaxis );
+
+    //VectorCopy (cg.refdef.vieworg, cg.refdef_current->vieworg);
+    //AnglesToAxis (cg.refdefViewAngles, cg.refdef_current->viewaxis);
+
+    return 0;
+}
+
+#if 0
+static void Wolfcam_AdjustZoomVal (float val, int type)
+{
+    //wclient_t *wc = &wclients[wcg.clientNum];
+
+#if 0
+    wc->zoomval += val;
+    if (wc->zoomval > zoomTable[type][ZOOM_OUT])
+        wc->zoomval = zoomTable[type][ZOOM_OUT];
+    if(wc->zoomval < zoomTable[type][ZOOM_IN])
+        wc->zoomval = zoomTable[type][ZOOM_IN];
+#endif
+}
+#endif
+
+
+void Wolfcam_ZoomIn (void)
+{
+    //centity_t *cent;
+
+#if 0
+    cent = &cg_entities[cgs.clientinfo[wcg.clientNum].clientNum];
+
+    if (cent->currentState.weapon == WP_SNIPERRIFLE) {
+        Wolfcam_AdjustZoomVal (-(cg_zoomStepSniper.value), ZOOM_SNIPER);
+    } else if (wclients[wcg.clientNum].zoomedBinoc) {
+        Wolfcam_AdjustZoomVal (-(cg_zoomStepSniper.value), ZOOM_SNIPER);
+    }
+#endif
+}
+
+void Wolfcam_ZoomOut (void)
+{
+    //centity_t *cent;
+
+#if 0
+    cent = &cg_entities[cgs.clientinfo[wcg.clientNum].clientNum];
+
+    if (cent->currentState.weapon == WP_SNIPERRIFLE) {
+        Wolfcam_AdjustZoomVal(cg_zoomStepSniper.value, ZOOM_SNIPER);
+    } else if (wclients[wcg.clientNum].zoomedBinoc) {
+        Wolfcam_AdjustZoomVal(cg_zoomStepSniper.value, ZOOM_SNIPER); // JPW NERVE per atvi request BINOC);
+    }
+#endif
+}
+
+
+void Wolfcam_Zoom (void)
+{
+    //entityState_t *es;
+    //wclient_t *wc;
+
+#if 0
+    es = &(cg_entities[cgs.clientinfo[wcg.clientNum].clientNum].currentState);
+    wc = &wclients[wcg.clientNum];
+
+	// OSP - Fix for demo playback
+	if ( (cg.snap->ps.pm_flags & PMF_FOLLOW) || cg.demoPlayback ) {
+		cg.predictedPlayerState.eFlags = cg.snap->ps.eFlags;
+		cg.predictedPlayerState.weapon = cg.snap->ps.weapon;
+
+		// check for scope wepon in use, and switch to if necessary
+		// OSP - spec/demo scaling allowances
+		if(es->weapon == WP_FG42SCOPE)
+			wc->zoomval = (wc->zoomval == 0) ? cg_zoomDefaultSniper.value : wc->zoomval; // JPW NERVE was DefaultFG, changed per atvi req
+		else if ( es->weapon == WP_SNIPERRIFLE )
+			wc->zoomval = (wc->zoomval == 0) ? cg_zoomDefaultSniper.value : wc->zoomval;
+		else if(!(es->eFlags & EF_ZOOMING))
+			wc->zoomval = 0;
+	}
+
+	if(es->eFlags & EF_ZOOMING) {
+		if ( wc->zoomedBinoc )
+			return;
+		wc->zoomedBinoc	= qtrue;
+		wc->zoomTime	= cg.time;
+		wc->zoomval = cg_zoomDefaultSniper.value; // JPW NERVE was DefaultBinoc, changed per atvi req
+	}
+	else {
+		if (wc->zoomedBinoc) {
+			wc->zoomedBinoc	= qfalse;
+			wc->zoomTime	= cg.time;
+
+			// check for scope weapon in use, and switch to if necessary
+			//if( cg.weaponSelect == WP_FG42SCOPE ) {
+            if (es->weapon == WP_FG42SCOPE) {
+				wc->zoomval = cg_zoomDefaultSniper.value; // JPW NERVE was DefaultFG, changed per atvi req
+			} else if ( es->weapon == WP_SNIPERRIFLE ) {
+				wc->zoomval = cg_zoomDefaultSniper.value;
+			} else {
+				wc->zoomval = 0;
+			}
+		} else {
+//bani - we now sanity check to make sure we can't zoom non-zoomable weapons
+//zinx - fix for #423 - don't sanity check while following
+			if (!((cg.snap->ps.pm_flags & PMF_FOLLOW) || cg.demoPlayback)) {
+				switch( es->weapon ) {
+					case WP_FG42SCOPE:
+					case WP_SNIPERRIFLE:
+						break;
+					default:
+						wc->zoomval = 0;
+						break;
+				}
+			}
+		}
+	}
+#endif
+}
+
+#define	WAVE_AMPLITUDE	1
+#define	WAVE_FREQUENCY	0.4
+
+int Wolfcam_CalcFov (void) 
+{
+#if 1  //FIXME wolfcam-rtcw
+	static float lastfov = 90;		// for transitions back from zoomed in modes
+	float	x;
+	float	phase;
+	float	v;
+	int		contents;
+	float	fov_x, fov_y;
+	float	zoomFov;
+	float	f;
+	int		inwater;
+    clientInfo_t *ci;
+    centity_t *cent;
+    entityState_t *es;
+    wclient_t *wc;
+
+    ci = &cgs.clientinfo[wcg.clientNum];
+    cent = &cg_entities[wcg.clientNum];
+    es = &cent->currentState;
+    wc = &wclients[wcg.clientNum];
+
+	Wolfcam_Zoom();
+
+	//if ( cg.predictedPlayerState.stats[STAT_HEALTH] <= 0 && !(cg.snap->ps.pm_flags & PMF_FOLLOW) ) 
+    if (es->eFlags & EF_DEAD)
+	{
+		wc->zoomedBinoc = qfalse;
+		wc->zoomTime = 0;
+		wc->zoomval = 0;
+	}
+
+	if ( cg.predictedPlayerState.pm_type == PM_INTERMISSION ) {
+		// if in intermission, use a fixed value
+		fov_x = 90;
+	} else {
+		fov_x = cg_fov.value;
+
+		//if( !cg.renderingThirdPerson || developer.integer ) {  //FIXME wolfcam
+        if ( !(es->eFlags & EF_DEAD) ) {  // ||  developer.integer) {
+			// account for zooms
+			if(wc->zoomval) {
+				zoomFov = wc->zoomval;	// (SA) use user scrolled amount
+
+				if ( zoomFov < 1 ) {
+					zoomFov = 1;
+				} else if ( zoomFov > 160 ) {
+					zoomFov = 160;
+				}
+			} else {
+					zoomFov = lastfov;
+			}
+			
+			// do smooth transitions for the binocs
+			if(wc->zoomedBinoc) {		// binoc zooming in
+				f = ( cg.time - wc->zoomTime ) / (float)ZOOM_TIME;
+				if ( f > 1.0 ) {
+					fov_x = zoomFov;
+				} else {
+					fov_x = fov_x + f * ( zoomFov - fov_x );
+				}
+				lastfov = fov_x;
+			} else if (wc->zoomval) {	// zoomed by sniper/snooper
+				fov_x = wc->zoomval;
+				lastfov = fov_x;
+			} else {					// binoc zooming out
+				f = ( cg.time - wc->zoomTime ) / (float)ZOOM_TIME;
+				if ( f > 1.0 ) {
+					fov_x = fov_x;
+				} else {
+					fov_x = zoomFov + f * ( fov_x - zoomFov);
+				}
+			}
+		}
+	}
+
+    //FIXME wolfcam hmm
+	//cg.refdef.rdflags &= ~RDF_SNOOPERVIEW;
+
+	// Arnout: mg42 zoom
+    //FIXME wolfcam check to see if attached to a gun
+	if (0) {  //if (cg.snap->ps.persistant[PERS_HWEAPON_USE]) {
+		fov_x = 55;
+        //} else if( es->weapon == WP_MOBILE_MG42_SET ) {
+		//fov_x = 55;
+        //} else if( es->eFlags & EF_MOUNTEDTANK ) {
+		//fov_x = 75;
+	}
+
+	//if( cg.showGameView ) {
+	//	fov_x = fov_y = 60.f;
+	//}
+
+	// Arnout: this is weird... (but ensures square pixel ratio!)
+	x = cg.refdef.width / tan( fov_x / 360 * M_PI );
+	fov_y = atan2( cg.refdef.height, x );
+	fov_y = fov_y * 360 / M_PI;
+	// And this seems better - but isn't really
+	//fov_y = fov_x / cgs.glconfig.windowAspect;
+
+	// warp if underwater
+	//if ( cg_pmove.waterlevel == 3 ) {
+	contents = CG_PointContents( cg.refdef.vieworg, -1 );  // wolfcam this is ok I think
+	if ( contents & ( CONTENTS_WATER | CONTENTS_SLIME | CONTENTS_LAVA ) ){
+		phase = cg.time / 1000.0 * WAVE_FREQUENCY * M_PI * 2;
+		v = WAVE_AMPLITUDE * sin( phase );
+		fov_x += v;
+		fov_y -= v;
+		inwater = qtrue;
+		//cg.refdef.rdflags |= RDF_UNDERWATER;
+	} else {
+#if 0
+		cg.refdef.rdflags &= ~RDF_UNDERWATER;
+		inwater = qfalse;
+#endif
+	}
+
+	// set it
+	cg.refdef.fov_x = fov_x;
+	cg.refdef.fov_y = fov_y;
+
+/*
+	if( cg.predictedPlayerState.eFlags & EF_PRONE ) {
+		cg.zoomSensitivity = cg.refdef.fov_y / 500.0;
+	} else
+*/
+	// rain - allow freelook when dead until we tap out into limbo
+	if (es->eFlags & EF_DEAD) {  //if( cg.snap->ps.pm_type == PM_FREEZE || (cg.snap->ps.pm_type == PM_DEAD && (cg.snap->ps.pm_flags & PMF_LIMBO)) || cg.snap->ps.pm_flags & PMF_TIME_LOCKPLAYER ) {  //FIXME wolfcam
+		// No movement for pauses
+		cg.zoomSensitivity = 0;
+	} else if ( !wc->zoomedBinoc ) {
+		// NERVE - SMF - fix for zoomed in/out movement bug
+		if ( wc->zoomval ) {
+			cg.zoomSensitivity = 0.6 * ( wc->zoomval / 90.f );	// NERVE - SMF - changed to get less sensitive as you zoom in
+//				cg.zoomSensitivity = 0.1;
+		} else {
+			cg.zoomSensitivity = 1;
+		}
+		// -NERVE - SMF
+	} else {
+		cg.zoomSensitivity = cg.refdef.fov_y / 75.0;
+	}
+
+	return inwater;
+#endif
+    
+    //return 0;
+
+}
diff -Naur cgame.orig/wolfcam_weapons.c cgame/wolfcam_weapons.c
--- cgame.orig/wolfcam_weapons.c	1969-12-31 19:00:00.000000000 -0500
+++ cgame/wolfcam_weapons.c	2007-08-24 12:36:36.000000000 -0400
@@ -0,0 +1,56 @@
+#include "cg_local.h"
+#include "wolfcam_local.h"
+
+qboolean Wolfcam_CalcMuzzlePoint (int entityNum, vec3_t muzzle, vec3_t forward, vec3_t right, vec3_t up, qboolean useLerp)
+{
+    vec3_t f;
+    centity_t *cent;
+    int anim;
+
+    cent = &cg_entities[entityNum];
+
+    if (entityNum == cg.snap->ps.clientNum) {
+        if (useLerp) {
+            VectorCopy (cent->lerpOrigin, muzzle);
+            muzzle[2] += cg.snap->ps.viewheight;
+            AngleVectors (cent->lerpAngles, f, right, up);
+            if (forward)
+                VectorCopy (f, forward);
+            VectorMA (muzzle, 14, f, muzzle);
+            return qtrue;
+        } else {
+            VectorCopy (cg.snap->ps.origin, muzzle);
+            muzzle[2] += cg.snap->ps.viewheight;
+            AngleVectors (cg.snap->ps.viewangles, f, right, up);
+            if (forward)
+                VectorCopy (f, forward);
+            VectorMA (muzzle, 14, f, muzzle);
+            return qtrue;
+        }
+    }
+
+    if (!cent->currentValid)
+        return qfalse;
+
+    if (useLerp) {
+        VectorCopy (cent->lerpOrigin, muzzle);
+        AngleVectors (cent->lerpAngles, f, right, up);
+    } else {
+        VectorCopy( cent->currentState.pos.trBase, muzzle );
+        AngleVectors (cent->currentState.apos.trBase, f, right, up);
+    }
+    if (forward)
+        VectorCopy (f, forward);
+
+    anim = cent->currentState.legsAnim & ~ANIM_TOGGLEBIT;
+    if ( anim == LEGS_WALKCR || anim == LEGS_IDLECR ) {
+        muzzle[2] += CROUCH_VIEWHEIGHT;
+    } else {
+        muzzle[2] += DEFAULT_VIEWHEIGHT;
+    }
+
+    VectorMA (muzzle, 14, f, muzzle);
+
+    return qtrue;
+}
+
